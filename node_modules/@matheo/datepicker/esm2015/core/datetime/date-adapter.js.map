{"version":3,"file":"date-adapter.js","sourceRoot":"","sources":["../../../../../../libs/datepicker/core/datetime/date-adapter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, Subject} from 'rxjs';\n\nexport type DateUnit =\n  | 'y' | 'year' | 'years'\n  | 'M' | 'month' | 'months'\n  | 'd' | 'day' | 'days'\n  | 'h' | 'hour' | 'hours'\n  | 'm' | 'minute' | 'minutes';\n\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\nexport abstract class DateAdapter<D> {\n  /** The locale to use for all dates. */\n  protected locale: any;\n  protected _localeChanges = new Subject<void>();\n\n  /** A stream that emits when the locale changes. */\n  readonly localeChanges: Observable<void> = this._localeChanges;\n\n  /**\n   * Gets the year component of the given date.\n   * @param date The date to extract the year from.\n   * @returns The year component.\n   */\n  abstract getYear(date: D): number;\n\n  /**\n   * Gets the month component of the given date.\n   * @param date The date to extract the month from.\n   * @returns The month component (0-indexed, 0 = January).\n   */\n  abstract getMonth(date: D): number;\n\n  abstract getHours(date: D): number;\n\n  abstract setHours(date: D, value: number): D;\n\n  abstract getMinutes(date: D): number;\n\n  abstract setMinutes(date: D, value: number): D;\n\n  abstract getSeconds(date: D): number;\n\n  abstract setSeconds(date: D, value: number, ms?: number): D;\n\n  abstract getMilliseconds(date: D): number;\n\n  /**\n   * Gets the date of the month component of the given date.\n   * @param date The date to extract the date of the month from.\n   * @returns The month component (1-indexed, 1 = first of month).\n   */\n  abstract getDate(date: D): number;\n\n  /**\n   * Gets the day of the week component of the given date.\n   * @param date The date to extract the day of the week from.\n   * @returns The month component (0-indexed, 0 = Sunday).\n   */\n  abstract getDayOfWeek(date: D): number;\n\n  /**\n   * Gets a list of names for the months.\n   * @param style The naming style (e.g. long = 'January', short = 'Jan', narrow = 'J').\n   * @returns An ordered list of all month names, starting with January.\n   */\n  abstract getMonthNames(style: 'long' | 'short' | 'narrow'): string[];\n\n  /**\n   * Gets a list of names for the dates of the month.\n   * @returns An ordered list of all date of the month names, starting with '1'.\n   */\n  abstract getDateNames(): string[];\n\n  abstract getHourNames(): string[];\n\n  abstract getMinuteNames(): string[];\n\n  /**\n   * Gets a list of names for the days of the week.\n   * @param style The naming style (e.g. long = 'Sunday', short = 'Sun', narrow = 'S').\n   * @returns An ordered list of all weekday names, starting with Sunday.\n   */\n  abstract getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];\n\n  /**\n   * Gets the name for the year of the given date.\n   * @param date The date to get the year name for.\n   * @returns The name of the given year (e.g. '2017').\n   */\n  abstract getYearName(date: D): string;\n\n  /**\n   * Gets the first day of the week.\n   * @returns The first day of the week (0-indexed, 0 = Sunday).\n   */\n  abstract getFirstDayOfWeek(): number;\n\n  /**\n   * Gets the number of days in the month of the given date.\n   * @param date The date whose month should be checked.\n   * @returns The number of days in the month of the given date.\n   */\n  abstract getNumDaysInMonth(date: D): number;\n\n  /**\n   * Clones the given date.\n   * @param date The date to clone\n   * @returns A new date equal to the given date.\n   */\n  abstract clone(date: D): D;\n\n  /**\n   * Creates a date with the given year, month, and date. Does not allow over/under-flow of the\n   * month and date.\n   * @param year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\n   * @param month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\n   * @param date The date of month of the date. Must be an integer 1 - length of the given month.\n   * @returns The new date, or null if invalid.\n   */\n  abstract createDate(\n    year: number,\n    month: number,\n    date: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): D;\n\n  /**\n   * Gets today's date.\n   * @returns Today's date.\n   */\n  abstract today(): D;\n\n  /**\n   * Parses a date from a user-provided value.\n   * @param value The value to parse.\n   * @param parseFormat The expected format of the value being parsed\n   *     (type is implementation-dependent).\n   * @returns The parsed date.\n   */\n  abstract parse(value: any, parseFormat: any): D | null;\n\n  /**\n   * Formats a date as a string according to the given format.\n   * @param date The value to format.\n   * @param displayFormat The format to use to display the date as a string.\n   * @returns The formatted date string.\n   */\n  abstract format(date: D, displayFormat: any): string;\n\n  /**\n   * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the\n   * calendar for each year and then finding the closest date in the new month. For example when\n   * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.\n   * @param date The date to add years to.\n   * @param years The number of years to add (may be negative).\n   * @returns A new date equal to the given one with the specified number of years added.\n   */\n  abstract addCalendarYears(date: D, years: number): D;\n\n  /**\n   * Adds the given number of months to the date. Months are counted as if flipping a page on the\n   * calendar for each month and then finding the closest date in the new month. For example when\n   * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.\n   * @param date The date to add months to.\n   * @param months The number of months to add (may be negative).\n   * @returns A new date equal to the given one with the specified number of months added.\n   */\n  abstract addCalendarMonths(date: D, months: number): D;\n\n  /**\n   * Adds the given number of days to the date. Days are counted as if moving one cell on the\n   * calendar for each day.\n   * @param date The date to add days to.\n   * @param days The number of days to add (may be negative).\n   * @returns A new date equal to the given one with the specified number of days added.\n   */\n  abstract addCalendarDays(date: D, days: number): D;\n\n  abstract addCalendarHours(date: D, hours: number): D;\n\n  abstract addCalendarMinutes(date: D, minutes: number): D;\n\n  abstract addCalendarSeconds(date: D, seconds: number, ms?: number): D;\n\n  /**\n   * Gets the RFC 3339 compatible string (https://tools.ietf.org/html/rfc3339) for the given date.\n   * This method is used to generate date strings that are compatible with native HTML attributes\n   * such as the `min` or `max` attribute of an `<input>`.\n   * @param date The date to get the ISO date string for.\n   * @returns The ISO date string date string.\n   */\n  abstract toIso8601(date: D): string;\n\n  /**\n   * Checks whether the given object is considered a date instance by this DateAdapter.\n   * @param obj The object to check\n   * @returns Whether the object is a date instance.\n   */\n  abstract isDateInstance(obj: any): boolean;\n\n  /**\n   * Checks whether the given date is valid.\n   * @param date The date to check.\n   * @returns Whether the date is valid.\n   */\n  abstract isValid(date: D): boolean;\n\n  /**\n   * Gets date instance that is not valid.\n   * @returns An invalid date.\n   */\n  abstract invalid(): D;\n\n /**\n  * Given a potential date object, returns that same date object if it is\n  * a valid date, or `null` if it's not a valid date.\n  * @param obj The object to check.\n  * @returns A date or `null`.\n  */\n  getValidDateOrNull(obj: unknown): D | null {\n    return this.isDateInstance(obj) && this.isValid(obj as D) ? obj as D : null;\n  }\n\n  /**\n   * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n   * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n   * string). The default implementation does not allow any deserialization, it simply checks that\n   * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n   * method on all of its `@Input()` properties that accept dates. It is therefore possible to\n   * support passing values from your backend directly to these properties by overriding this method\n   * to also deserialize the format used by your backend.\n   * @param value The value to be deserialized into a date object.\n   * @returns The deserialized date object, either a valid date, null if the value can be\n   *     deserialized into a null date (e.g. the empty string), or an invalid date.\n   */\n  deserialize(value: any): D | null {\n    if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n      return value;\n    }\n    return this.invalid();\n  }\n\n  /**\n   * Sets the locale used for all dates.\n   * @param locale The new locale.\n   */\n  setLocale(locale: any) {\n    this.locale = locale;\n    this._localeChanges.next();\n  }\n\n  /**\n   * Compares two dates.\n   * @param first The first date to compare.\n   * @param second The second date to compare.\n   * @param unit Unit deep of the comparision.\n   * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n   *     a number greater than 0 if the first date is later.\n   */\n  compareDate(first: D, second: D, unit: DateUnit = 'minute'): number {\n    let d1 = this.getYear(first).toString();\n    let d2 = this.getYear(second).toString();\n\n    if (['y', 'year', 'years'].includes(unit)) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getMonth(first).toString().padStart(2, '0');\n    d2 += this.getMonth(second).toString().padStart(2, '0');\n\n    if (['M', 'month', 'months'].includes(unit)) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getDate(first).toString().padStart(2, '0');\n    d2 += this.getDate(second).toString().padStart(2, '0');\n\n    if (['d', 'day', 'days'].includes(unit)) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getHours(first).toString().padStart(2, '0');\n    d2 += this.getHours(second).toString().padStart(2, '0');\n\n    if (['h', 'hour', 'hours'].indexOf(unit) >= 0) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getMinutes(first).toString().padStart(2, '0');\n    d2 += this.getMinutes(second).toString().padStart(2, '0');\n\n    return Number(d1) - Number(d2);\n  }\n\n  /**\n   * Checks if two dates are equal.\n   * @param first The first date to check.\n   * @param second The second date to check.\n   * @returns Whether the two dates are equal.\n   *     Null dates are considered equal to other null dates.\n   */\n  sameDate(first: D | null, second: D | null, unit: DateUnit = 'minute'): boolean {\n    if (first && second) {\n      let firstValid = this.isValid(first);\n      let secondValid = this.isValid(second);\n      if (firstValid && secondValid) {\n        return !this.compareDate(first, second, unit);\n      }\n      return firstValid == secondValid;\n    }\n    return first == second;\n  }\n\n  /**\n   * Clamp the given date between min and max dates.\n   * @param date The date to clamp.\n   * @param min The minimum value to allow. If null or omitted no min is enforced.\n   * @param max The maximum value to allow. If null or omitted no max is enforced.\n   * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n   *     otherwise `date`.\n   */\n  clampDate(date: D, min?: D | null, max?: D | null, unit: DateUnit = 'minute'): D {\n    if (min && this.compareDate(date, min, unit) < 0) {\n      return min;\n    }\n    if (max && this.compareDate(date, max, unit) > 0) {\n      return max;\n    }\n    return date;\n  }\n}\n"]}