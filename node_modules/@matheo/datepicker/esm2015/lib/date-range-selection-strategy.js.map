{"version":3,"file":"date-range-selection-strategy.js","sourceRoot":"","sources":["../../../../../libs/datepicker/src/lib/date-range-selection-strategy.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,UAAU,EAAE,cAAc,EAAE,QAAQ,EAAE,QAAQ,EAAkB,MAAM,eAAe,CAAC;AAC9F,OAAO,EAAC,WAAW,EAAC,MAAM,yBAAyB,CAAC;AACpD,OAAO,EAAC,SAAS,EAAC,MAAM,wBAAwB,CAAC;;;AAEjD,2EAA2E;AAC3E,MAAM,CAAC,MAAM,iCAAiC,GAC1C,IAAI,cAAc,CAAqC,mCAAmC,CAAC,CAAC;AA0BhG,0DAA0D;AAE1D,MAAM,OAAO,+BAA+B;IAC1C,YAAoB,YAA4B;QAA5B,iBAAY,GAAZ,YAAY,CAAgB;IAAG,CAAC;IAEpD,iBAAiB,CAAC,IAAO,EAAE,YAA0B;QACnD,IAAI,EAAC,KAAK,EAAE,GAAG,EAAC,GAAG,YAAY,CAAC;QAEhC,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,KAAK,GAAG,IAAI,CAAC;SACd;aAAM,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;YACjF,GAAG,GAAG,IAAI,CAAC;SACZ;aAAM;YACL,KAAK,GAAG,IAAI,CAAC;YACb,GAAG,GAAG,IAAI,CAAC;SACZ;QAED,OAAO,IAAI,SAAS,CAAI,KAAK,EAAE,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,aAAa,CAAC,UAAoB,EAAE,YAA0B;QAC5D,IAAI,KAAK,GAAa,IAAI,CAAC;QAC3B,IAAI,GAAG,GAAa,IAAI,CAAC;QAEzB,IAAI,YAAY,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,UAAU,EAAE;YACzD,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC;YAC3B,GAAG,GAAG,UAAU,CAAC;SAClB;QAED,OAAO,IAAI,SAAS,CAAI,KAAK,EAAE,GAAG,CAAC,CAAC;IACtC,CAAC;;gJA5BU,+BAA+B;oJAA/B,+BAA+B;4FAA/B,+BAA+B;kBAD3C,UAAU;;AAiCX,oBAAoB;AACpB,MAAM,UAAU,4CAA4C,CAC1D,MAA8C,EAAE,OAA6B;IAC7E,OAAO,MAAM,IAAI,IAAI,+BAA+B,CAAC,OAAO,CAAC,CAAC;AAChE,CAAC;AAED,oBAAoB;AACpB,MAAM,CAAC,MAAM,oCAAoC,GAAoB;IACnE,OAAO,EAAE,iCAAiC;IAC1C,IAAI,EAAE,CAAC,CAAC,IAAI,QAAQ,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,iCAAiC,CAAC,EAAE,WAAW,CAAC;IACxF,UAAU,EAAE,4CAA4C;CACzD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, InjectionToken, Optional, SkipSelf, FactoryProvider} from '@angular/core';\nimport {DateAdapter} from '@matheo/datepicker/core';\nimport {DateRange} from './date-selection-model';\n\n/** Injection token used to customize the date range selection behavior. */\nexport const MAT_DATE_RANGE_SELECTION_STRATEGY =\n    new InjectionToken<MatDateRangeSelectionStrategy<any>>('MAT_DATE_RANGE_SELECTION_STRATEGY');\n\n/** Object that can be provided in order to customize the date range selection behavior. */\nexport interface MatDateRangeSelectionStrategy<D> {\n  /**\n   * Called when the user has finished selecting a value.\n   * @param date Date that was selected. Will be null if the user cleared the selection.\n   * @param currentRange Range that is currently show in the calendar.\n   * @param event DOM event that triggered the selection. Currently only corresponds to a `click`\n   *    event, but it may get expanded in the future.\n   */\n  selectionFinished(date: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;\n\n  /**\n   * Called when the user has activated a new date (e.g. by hovering over\n   * it or moving focus) and the calendar tries to display a date range.\n   *\n   * @param activeDate Date that the user has activated. Will be null if the user moved\n   *    focus to an element that's no a calendar cell.\n   * @param currentRange Range that is currently shown in the calendar.\n   * @param event DOM event that caused the preview to be changed. Will be either a\n   *    `mouseenter`/`mouseleave` or `focus`/`blur` depending on how the user is navigating.\n   */\n  createPreview(activeDate: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;\n}\n\n/** Provides the default date range selection behavior. */\n@Injectable()\nexport class DefaultMatCalendarRangeStrategy<D> implements MatDateRangeSelectionStrategy<D> {\n  constructor(private _dateAdapter: DateAdapter<D>) {}\n\n  selectionFinished(date: D, currentRange: DateRange<D>) {\n    let {start, end} = currentRange;\n\n    if (start == null) {\n      start = date;\n    } else if (end == null && date && this._dateAdapter.compareDate(date, start) >= 0) {\n      end = date;\n    } else {\n      start = date;\n      end = null;\n    }\n\n    return new DateRange<D>(start, end);\n  }\n\n  createPreview(activeDate: D | null, currentRange: DateRange<D>) {\n    let start: D | null = null;\n    let end: D | null = null;\n\n    if (currentRange.start && !currentRange.end && activeDate) {\n      start = currentRange.start;\n      end = activeDate;\n    }\n\n    return new DateRange<D>(start, end);\n  }\n}\n\n\n/** @docs-private */\nexport function MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY(\n  parent: MatDateRangeSelectionStrategy<unknown>, adapter: DateAdapter<unknown>) {\n  return parent || new DefaultMatCalendarRangeStrategy(adapter);\n}\n\n/** @docs-private */\nexport const MAT_CALENDAR_RANGE_STRATEGY_PROVIDER: FactoryProvider = {\n  provide: MAT_DATE_RANGE_SELECTION_STRATEGY,\n  deps: [[new Optional(), new SkipSelf(), MAT_DATE_RANGE_SELECTION_STRATEGY], DateAdapter],\n  useFactory: MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY,\n};\n"]}