{"version":3,"file":"date-selection-model.js","sourceRoot":"","sources":["../../../../../libs/datepicker/src/lib/date-selection-model.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAkB,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAa,SAAS,EAAE,SAAS,EAAC,MAAM,eAAe,CAAC;AAC/G,OAAO,EAAa,OAAO,EAAC,MAAM,MAAM,CAAC;AACzC,OAAO,EAAC,WAAW,EAAC,MAAM,yBAAyB,CAAC;;;AAEpD,6CAA6C;AAC7C,MAAM,OAAO,SAAS;IAQpB;IACE,mCAAmC;IAC1B,KAAe;IACxB,iCAAiC;IACxB,GAAa;QAFb,UAAK,GAAL,KAAK,CAAU;QAEf,QAAG,GAAH,GAAG,CAAU;IAAG,CAAC;CAC7B;AAiBD,qDAAqD;AACrD,WAAW;AAEX,MAAM,OAAgB,qBAAqB;IAOzC;IACE,6BAA6B;IACpB,SAAY,EACX,QAAwB;QADzB,cAAS,GAAT,SAAS,CAAG;QACX,aAAQ,GAAR,QAAQ,CAAgB;QAR5B,sBAAiB,GAAG,IAAI,OAAO,EAA+B,CAAC;QAEvE,4CAA4C;QAC5C,qBAAgB,GAA4C,IAAI,CAAC,iBAAiB,CAAC;QAMjF,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAED;;;;OAIG;IACH,eAAe,CAAC,KAAQ,EAAE,MAAe;QACtC,IAAuB,CAAC,SAAS,GAAG,KAAK,CAAC;QAC3C,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAC,SAAS,EAAE,KAAK,EAAE,MAAM,EAAC,CAAC,CAAC;IAC1D,CAAC;IAED,WAAW;QACT,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,CAAC;IACpC,CAAC;IAES,oBAAoB,CAAC,IAAO;QACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAC3E,CAAC;IAeD;;;;OAIG;IACH,KAAK;QACH,IAAI,SAAS,EAAE,EAAE;YACf,MAAM,KAAK,CAAC,iBAAiB,CAAC,CAAC;SAChC;QAED,OAAO,IAAK,CAAC;IACf,CAAC;;sIAxDmB,qBAAqB;0HAArB,qBAAqB;4FAArB,qBAAqB;kBAD1C,SAAS;;AA4DV,sDAAsD;AAEtD,MAAM,OAAO,2BAA+B,SAAQ,qBAAkC;IAIpF,YAAY,OAAuB;QACjC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACvB,CAAC;IAED;;;OAGG;IACH,GAAG,CAAC,IAAc;QAChB,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC;IAED,+EAA+E;IAC/E,KAAK,CAAC,IAAc;QAClB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;IAC1B,CAAC;IAED,YAAY;QACV,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;SAC9C;IACH,CAAC;IAED,qDAAqD;IACrD,OAAO;QACL,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,IAAI,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAC7E,CAAC;IAED;;;OAGG;IACH,UAAU;QACR,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC;IAChC,CAAC;IAED,kCAAkC;IAClC,KAAK;QACH,MAAM,KAAK,GAAG,IAAI,2BAA2B,CAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;QAChE,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAC/B;QACD,OAAO,KAAK,CAAC;IACf,CAAC;;4IAhDU,2BAA2B;gJAA3B,2BAA2B;4FAA3B,2BAA2B;kBADvC,UAAU;;AAoDX,qDAAqD;AAErD,MAAM,OAAO,0BAA8B,SAAQ,qBAAsC;IACvF,YAAY,OAAuB;QACjC,KAAK,CAAC,IAAI,SAAS,CAAI,IAAI,EAAE,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACH,GAAG,CAAC,IAAc;QAChB,IAAI,EAAC,KAAK,EAAE,GAAG,EAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QAElC,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,KAAK,GAAG,IAAI,CAAC;SACd;aAAM,IAAI,GAAG,IAAI,IAAI,EAAE;YACtB,GAAG,GAAG,IAAI,CAAC;SACZ;aAAM;YACL,KAAK,GAAG,IAAI,CAAC;YACb,GAAG,GAAG,IAAI,CAAC;SACZ;QAED,KAAK,CAAC,eAAe,CAAC,IAAI,SAAS,CAAI,KAAK,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;IAC5D,CAAC;IAED,KAAK,CAAC,IAAc,IAAG,CAAC;IACxB,YAAY,KAAI,CAAC;IAEjB,qDAAqD;IACrD,OAAO;QACL,MAAM,EAAC,KAAK,EAAE,GAAG,EAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QAEpC,0BAA0B;QAC1B,IAAI,KAAK,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE;YAChC,OAAO,IAAI,CAAC;SACb;QAED,0FAA0F;QAC1F,IAAI,KAAK,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE;YAChC,OAAO,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC;gBAClE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;SACnD;QAED,sDAAsD;QACtD,OAAO,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;YACnD,CAAC,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,CAAC;IACzD,CAAC;IAED;;;OAGG;IACH,UAAU;QACR,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,IAAI,CAAC;IACpE,CAAC;IAED,kCAAkC;IAClC,KAAK;QACH,MAAM,KAAK,GAAG,IAAI,0BAA0B,CAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC/D,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAC5C,OAAO,KAAK,CAAC;IACf,CAAC;;2IA7DU,0BAA0B;+IAA1B,0BAA0B;4FAA1B,0BAA0B;kBADtC,UAAU;;AAiEX,oBAAoB;AACpB,MAAM,UAAU,uCAAuC,CACnD,MAA4C,EAAE,OAA6B;IAC7E,OAAO,MAAM,IAAI,IAAI,2BAA2B,CAAC,OAAO,CAAC,CAAC;AAC5D,CAAC;AAED,+DAA+D;AAC/D,MAAM,CAAC,MAAM,wCAAwC,GAAoB;IACvE,OAAO,EAAE,qBAAqB;IAC9B,IAAI,EAAE,CAAC,CAAC,IAAI,QAAQ,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,qBAAqB,CAAC,EAAE,WAAW,CAAC;IAC5E,UAAU,EAAE,uCAAuC;CACpD,CAAC;AAGF,oBAAoB;AACpB,MAAM,UAAU,sCAAsC,CAClD,MAA4C,EAAE,OAA6B;IAC7E,OAAO,MAAM,IAAI,IAAI,0BAA0B,CAAC,OAAO,CAAC,CAAC;AAC3D,CAAC;AAED,8DAA8D;AAC9D,MAAM,CAAC,MAAM,uCAAuC,GAAoB;IACtE,OAAO,EAAE,qBAAqB;IAC9B,IAAI,EAAE,CAAC,CAAC,IAAI,QAAQ,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,qBAAqB,CAAC,EAAE,WAAW,CAAC;IAC5E,UAAU,EAAE,sCAAsC;CACnD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FactoryProvider, Injectable, Optional, SkipSelf, OnDestroy, Directive, isDevMode} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\nimport {DateAdapter} from '@matheo/datepicker/core';\n\n/** A class representing a range of dates. */\nexport class DateRange<D> {\n  /**\n   * Ensures that objects with a `start` and `end` property can't be assigned to a variable that\n   * expects a `DateRange`\n   */\n  // tslint:disable-next-line:no-unused-variable\n  private _disableStructuralEquivalency: never;\n\n  constructor(\n    /** The start date of the range. */\n    readonly start: D | null,\n    /** The end date of the range. */\n    readonly end: D | null) {}\n}\n\n/**\n * Conditionally picks the date type, if a DateRange is passed in.\n * @docs-private\n */\nexport type ExtractDateTypeFromSelection<T> = T extends DateRange<infer D> ? D : NonNullable<T>;\n\n/** Event emitted by the date selection model when its selection changes. */\nexport interface DateSelectionModelChange<S> {\n  /** New value for the selection. */\n  selection: S;\n\n  /** Object that triggered the change. */\n  source: unknown;\n}\n\n/** A selection model containing a date selection. */\n// @dynamic\n@Directive()\nexport abstract class MatDateSelectionModel<S, D = ExtractDateTypeFromSelection<S>>\n    implements OnDestroy {\n  private _selectionChanged = new Subject<DateSelectionModelChange<S>>();\n\n  /** Emits when the selection has changed. */\n  selectionChanged: Observable<DateSelectionModelChange<S>> = this._selectionChanged;\n\n  protected constructor(\n    /** The current selection. */\n    readonly selection: S,\n    protected _adapter: DateAdapter<D>) {\n    this.selection = selection;\n  }\n\n  /**\n   * Updates the current selection in the model.\n   * @param value New selection that should be assigned.\n   * @param source Object that triggered the selection change.\n   */\n  updateSelection(value: S, source: unknown) {\n    (this as {selection: S}).selection = value;\n    this._selectionChanged.next({selection: value, source});\n  }\n\n  ngOnDestroy() {\n    this._selectionChanged.complete();\n  }\n\n  protected _isValidDateInstance(date: D): boolean {\n    return this._adapter.isDateInstance(date) && this._adapter.isValid(date);\n  }\n\n  /** Adds a date to the current selection. */\n  abstract add(date: D | null): void;\n\n  /** Adds a date as pending to update if the user selects the date partially. */\n  abstract queue(date: D | null): void;\n  abstract processQueue(): void;\n\n  /** Checks whether the current selection is valid. */\n  abstract isValid(): boolean;\n\n  /** Checks whether the current selection is complete. */\n  abstract isComplete(): boolean;\n\n  /**\n   * Clones the selection model.\n   * @deprecated To be turned into an abstract method.\n   * @breaking-change 12.0.0\n   */\n  clone(): MatDateSelectionModel<S, D> {\n    if (isDevMode()) {\n      throw Error('Not implemented');\n    }\n\n    return null!;\n  }\n}\n\n/**  A selection model that contains a single date. */\n@Injectable()\nexport class MatSingleDateSelectionModel<D> extends MatDateSelectionModel<D | null, D> {\n  /** Queue store */\n  queuedValue: D;\n\n  constructor(adapter: DateAdapter<D>) {\n    super(null, adapter);\n  }\n\n  /**\n   * Adds a date to the current selection. In the case of a single date selection, the added date\n   * simply overwrites the previous selection\n   */\n  add(date: D | null) {\n    super.updateSelection(date, this);\n  }\n\n  /** Adds a date as pending to update if the user selects the date partially. */\n  queue(date: D | null) {\n    this.queuedValue = date;\n  }\n\n  processQueue(): void {\n    if (this.queuedValue) {\n      this.updateSelection(this.queuedValue, this);\n    }\n  }\n\n  /** Checks whether the current selection is valid. */\n  isValid(): boolean {\n    return this.selection != null && this._isValidDateInstance(this.selection);\n  }\n\n  /**\n   * Checks whether the current selection is complete. In the case of a single date selection, this\n   * is true if the current selection is not null.\n   */\n  isComplete() {\n    return this.selection != null;\n  }\n\n  /** Clones the selection model. */\n  clone() {\n    const clone = new MatSingleDateSelectionModel<D>(this._adapter);\n    clone.updateSelection(this.selection, this);\n    if (this.queuedValue) {\n      clone.queue(this.queuedValue);\n    }\n    return clone;\n  }\n}\n\n/**  A selection model that contains a date range. */\n@Injectable()\nexport class MatRangeDateSelectionModel<D> extends MatDateSelectionModel<DateRange<D>, D> {\n  constructor(adapter: DateAdapter<D>) {\n    super(new DateRange<D>(null, null), adapter);\n  }\n\n  /**\n   * Adds a date to the current selection. In the case of a date range selection, the added date\n   * fills in the next `null` value in the range. If both the start and the end already have a date,\n   * the selection is reset so that the given date is the new `start` and the `end` is null.\n   */\n  add(date: D | null): void {\n    let {start, end} = this.selection;\n\n    if (start == null) {\n      start = date;\n    } else if (end == null) {\n      end = date;\n    } else {\n      start = date;\n      end = null;\n    }\n\n    super.updateSelection(new DateRange<D>(start, end), this);\n  }\n\n  queue(date: D | null) {}\n  processQueue() {}\n\n  /** Checks whether the current selection is valid. */\n  isValid(): boolean {\n    const {start, end} = this.selection;\n\n    // Empty ranges are valid.\n    if (start == null && end == null) {\n      return true;\n    }\n\n    // Complete ranges are only valid if both dates are valid and the start is before the end.\n    if (start != null && end != null) {\n      return this._isValidDateInstance(start) && this._isValidDateInstance(end) &&\n             this._adapter.compareDate(start, end) <= 0;\n    }\n\n    // Partial ranges are valid if the start/end is valid.\n    return (start == null || this._isValidDateInstance(start)) &&\n           (end == null || this._isValidDateInstance(end));\n  }\n\n  /**\n   * Checks whether the current selection is complete. In the case of a date range selection, this\n   * is true if the current selection has a non-null `start` and `end`.\n   */\n  isComplete(): boolean {\n    return this.selection.start != null && this.selection.end != null;\n  }\n\n  /** Clones the selection model. */\n  clone() {\n    const clone = new MatRangeDateSelectionModel<D>(this._adapter);\n    clone.updateSelection(this.selection, this);\n    return clone;\n  }\n}\n\n/** @docs-private */\nexport function MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY(\n    parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>) {\n  return parent || new MatSingleDateSelectionModel(adapter);\n}\n\n/** Used to provide a single selection model to a component. */\nexport const MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider = {\n  provide: MatDateSelectionModel,\n  deps: [[new Optional(), new SkipSelf(), MatDateSelectionModel], DateAdapter],\n  useFactory: MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY,\n};\n\n\n/** @docs-private */\nexport function MAT_RANGE_DATE_SELECTION_MODEL_FACTORY(\n    parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>) {\n  return parent || new MatRangeDateSelectionModel(adapter);\n}\n\n/** Used to provide a range selection model to a component. */\nexport const MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider = {\n  provide: MatDateSelectionModel,\n  deps: [[new Optional(), new SkipSelf(), MatDateSelectionModel], DateAdapter],\n  useFactory: MAT_RANGE_DATE_SELECTION_MODEL_FACTORY,\n};\n"]}