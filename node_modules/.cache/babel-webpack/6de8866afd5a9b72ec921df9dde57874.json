{"ast":null,"code":"import * as i10 from '@angular/cdk/a11y';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport * as i10$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport * as i9 from '@angular/cdk/portal';\nimport { ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport * as i4 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Inject, Input, Output, HostListener, isDevMode, Directive, SkipSelf, InjectionToken, ViewChild, forwardRef, HostBinding, Attribute, ContentChild, InjectFlags, Self, TemplateRef, NgModule } from '@angular/core';\nimport * as i3 from '@angular/material/button';\nimport { MatButtonModule } from '@angular/material/button';\nimport * as i9$1 from '@angular/material/dialog';\nimport { MatDialogModule } from '@angular/material/dialog';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/material/core';\nimport { MAT_DATE_FORMATS, mixinColor, mixinErrorState, MatCommonModule } from '@angular/material/core';\nimport { Subject, Subscription, merge, of } from 'rxjs';\nimport * as i1 from '@matheo/datepicker/core';\nimport { DateAdapter } from '@matheo/datepicker/core';\nimport { trigger, state, style, transition, animate, keyframes } from '@angular/animations';\nimport { ESCAPE, hasModifierKey, SPACE, ENTER, PAGE_DOWN, PAGE_UP, END, HOME, DOWN_ARROW, UP_ARROW, RIGHT_ARROW, LEFT_ARROW, BACKSPACE } from '@angular/cdk/keycodes';\nimport * as i2 from '@angular/cdk/bidi';\nimport { take, startWith, filter } from 'rxjs/operators';\nimport { coerceBooleanProperty, coerceStringArray } from '@angular/cdk/coercion';\nimport * as i2$2 from '@angular/forms';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, Validators, NgControl } from '@angular/forms';\nimport * as i2$1 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD, MatFormFieldControl } from '@angular/material/form-field';\nimport { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Animations used by the Material datepicker.\n * @docs-private\n */\n\nfunction MatClockView_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r2 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"top\", item_r2.top, \"%\")(\"left\", item_r2.left, \"%\")(\"font-size\", item_r2.fontSize);\n    i0.ɵɵclassProp(\"mat-clock-cell-selected\", ctx_r0._selectedHour == item_r2.value)(\"mat-clock-cell-disabled\", !item_r2.enabled);\n    i0.ɵɵproperty(\"ngClass\", item_r2.cssClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r2.displayValue, \" \");\n  }\n}\n\nfunction MatClockView_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r3 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"top\", item_r3.top, \"%\")(\"left\", item_r3.left, \"%\");\n    i0.ɵɵclassProp(\"mat-clock-cell-selected\", ctx_r1._selectedMinute == item_r3.value)(\"mat-clock-cell-disabled\", !item_r3.enabled);\n    i0.ɵɵproperty(\"ngClass\", item_r3.cssClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r3.displayValue, \" \");\n  }\n}\n\nconst _c0 = [\"mat-calendar-body\", \"\"];\n\nfunction MatCalendarBody_tr_0_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"padding-top\", ctx_r3._cellPadding)(\"padding-bottom\", ctx_r3._cellPadding);\n    i0.ɵɵattribute(\"colspan\", ctx_r3._firstRowOffset);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3._firstRowOffset >= ctx_r3.labelMinRequiredCells ? ctx_r3.label : \"\", \" \");\n  }\n}\n\nfunction MatCalendarBody_tr_0_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"td\", 5);\n    i0.ɵɵlistener(\"click\", function MatCalendarBody_tr_0_td_2_Template_td_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const item_r5 = restoredCtx.$implicit;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7._cellClicked(item_r5, $event);\n    });\n    i0.ɵɵelementStart(1, \"div\", 6);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(3, \"div\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r5 = ctx.$implicit;\n    const colIndex_r6 = ctx.index;\n    const rowIndex_r2 = i0.ɵɵnextContext().index;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r4._cellWidth)(\"padding-top\", ctx_r4._cellPadding)(\"padding-bottom\", ctx_r4._cellPadding);\n    i0.ɵɵclassProp(\"mat-calendar-body-disabled\", !item_r5.enabled)(\"mat-calendar-body-active\", ctx_r4._isActiveCell(rowIndex_r2, colIndex_r6))(\"mat-calendar-body-range-start\", ctx_r4._isRangeStart(item_r5.compareValue))(\"mat-calendar-body-range-end\", ctx_r4._isRangeEnd(item_r5.compareValue))(\"mat-calendar-body-in-range\", ctx_r4._isInRange(item_r5.compareValue))(\"mat-calendar-body-comparison-bridge-start\", ctx_r4._isComparisonBridgeStart(item_r5.compareValue, rowIndex_r2, colIndex_r6))(\"mat-calendar-body-comparison-bridge-end\", ctx_r4._isComparisonBridgeEnd(item_r5.compareValue, rowIndex_r2, colIndex_r6))(\"mat-calendar-body-comparison-start\", ctx_r4._isComparisonStart(item_r5.compareValue))(\"mat-calendar-body-comparison-end\", ctx_r4._isComparisonEnd(item_r5.compareValue))(\"mat-calendar-body-in-comparison-range\", ctx_r4._isInComparisonRange(item_r5.compareValue))(\"mat-calendar-body-preview-start\", ctx_r4._isPreviewStart(item_r5.compareValue))(\"mat-calendar-body-preview-end\", ctx_r4._isPreviewEnd(item_r5.compareValue))(\"mat-calendar-body-in-preview\", ctx_r4._isInPreview(item_r5.compareValue));\n    i0.ɵɵproperty(\"ngClass\", item_r5.cssClasses)(\"tabindex\", ctx_r4._isActiveCell(rowIndex_r2, colIndex_r6) ? 0 : -1);\n    i0.ɵɵattribute(\"data-mat-row\", rowIndex_r2)(\"data-mat-col\", colIndex_r6)(\"aria-label\", item_r5.ariaLabel)(\"aria-disabled\", !item_r5.enabled || null)(\"aria-selected\", ctx_r4._isSelected(item_r5.compareValue));\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-calendar-body-selected\", ctx_r4._isSelected(item_r5.compareValue))(\"mat-calendar-body-comparison-identical\", ctx_r4._isComparisonIdentical(item_r5.compareValue))(\"mat-calendar-body-today\", ctx_r4.todayValue === item_r5.compareValue);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r5.displayValue, \" \");\n  }\n}\n\nfunction MatCalendarBody_tr_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 1);\n    i0.ɵɵtemplate(1, MatCalendarBody_tr_0_td_1_Template, 2, 6, \"td\", 2);\n    i0.ɵɵtemplate(2, MatCalendarBody_tr_0_td_2_Template, 4, 46, \"td\", 3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r1 = ctx.$implicit;\n    const rowIndex_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", rowIndex_r2 === 0 && ctx_r0._firstRowOffset);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r1);\n  }\n}\n\nfunction MatMonthView_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const day_r1 = ctx.$implicit;\n    i0.ɵɵattribute(\"aria-label\", day_r1.long);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(day_r1.narrow);\n  }\n}\n\nconst _c1 = function () {\n  return [\"multi-year\"];\n};\n\nfunction MatCalendarHeader_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelementStart(1, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_2_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.switchToView(\"multi-year\");\n    });\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r0.isControlActive(i0.ɵɵpureFunction0(5, _c1)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r0.isControlActive(i0.ɵɵpureFunction0(6, _c1)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r0._intl.switchToMultiYearViewLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0._yearButtonText);\n  }\n}\n\nconst _c2 = function () {\n  return [\"year\"];\n};\n\nfunction MatCalendarHeader_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelementStart(1, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_3_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.switchToView(\"year\");\n    });\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_3_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.switchToView(\"multi-year\");\n    });\n    i0.ɵɵelementStart(5, \"span\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r1.isControlActive(i0.ɵɵpureFunction0(10, _c2)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r1.isControlActive(i0.ɵɵpureFunction0(11, _c2)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r1._intl.switchToYearViewLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1._monthButtonText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r1.isControlActive(i0.ɵɵpureFunction0(12, _c1)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r1.isControlActive(i0.ɵɵpureFunction0(13, _c1)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r1._intl.switchToMultiYearViewLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1._yearButtonText);\n  }\n}\n\nconst _c3 = function () {\n  return [\"month\", \"year\"];\n};\n\nfunction MatCalendarHeader_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelementStart(1, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_4_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.switchToView(\"multi-year\");\n    });\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_4_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.monthdayClicked();\n    });\n    i0.ɵɵelementStart(5, \"span\", 9);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"span\", 10);\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r2.isControlActive(i0.ɵɵpureFunction0(11, _c1)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r2.isControlActive(i0.ɵɵpureFunction0(12, _c1)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r2._intl.switchToMultiYearViewLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r2._yearButtonText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r2.isControlActive(i0.ɵɵpureFunction0(13, _c3)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r2.isControlActive(i0.ɵɵpureFunction0(14, _c3)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.monthdayButtonLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r2._dayButtonText, \"\\xA0\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r2._monthdayButtonText);\n  }\n}\n\nfunction MatCalendarHeader_div_5_div_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵelementStart(1, \"button\", 18);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_5_div_10_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext(2);\n      return ctx_r14.toggleAmPm(true);\n    });\n    i0.ɵɵtext(2, \" AM \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 18);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_5_div_10_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return ctx_r16.toggleAmPm(false);\n    });\n    i0.ɵɵtext(4, \" PM \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r13._isAM);\n    i0.ɵɵproperty(\"@controlActive\", ctx_r13._isAM ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r13._intl.setToAMLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", !ctx_r13._isAM);\n    i0.ɵɵproperty(\"@controlActive\", !ctx_r13._isAM ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r13._intl.setToPMLabel);\n  }\n}\n\nconst _c4 = function () {\n  return [\"hour\"];\n};\n\nconst _c5 = function () {\n  return [\"minute\"];\n};\n\nfunction MatCalendarHeader_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵelementStart(1, \"div\", 12);\n    i0.ɵɵelementStart(2, \"button\", 13);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_5_Template_button_click_2_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.switchToView(\"hour\");\n    });\n    i0.ɵɵelementStart(3, \"span\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\", 14);\n    i0.ɵɵtext(6, \":\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"button\", 15);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_5_Template_button_click_7_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.switchToView(\"minute\");\n    });\n    i0.ɵɵelementStart(8, \"span\");\n    i0.ɵɵtext(9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(10, MatCalendarHeader_div_5_div_10_Template, 5, 8, \"div\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r3.isControlActive(i0.ɵɵpureFunction0(11, _c4)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r3.isControlActive(i0.ɵɵpureFunction0(12, _c4)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r3._intl.switchToHourViewLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3._hourButtonText);\n    i0.ɵɵadvance(3);\n    i0.ɵɵclassProp(\"mat-custom-control-active\", ctx_r3.isControlActive(i0.ɵɵpureFunction0(13, _c5)));\n    i0.ɵɵproperty(\"@controlActive\", ctx_r3.isControlActive(i0.ɵɵpureFunction0(14, _c5)) ? \"active\" : \"\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r3._intl.switchToMinuteViewLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3._minuteButtonText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.calendar.twelveHour);\n  }\n}\n\nfunction MatCalendarHeader_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 19);\n    i0.ɵɵelementStart(1, \"button\", 20);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_6_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20.previousClicked();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"button\", 21);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_6_Template_button_click_2_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return ctx_r22.currentPeriodClicked();\n    });\n    i0.ɵɵelementStart(3, \"strong\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"button\", 22);\n    i0.ɵɵlistener(\"click\", function MatCalendarHeader_div_6_Template_button_click_5_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return ctx_r23.nextClicked();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", !ctx_r4.previousEnabled());\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.prevButtonLabel);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", ctx_r4.currentPeriodDisabled());\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.periodButtonLabel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r4.periodButtonText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", !ctx_r4.nextEnabled());\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.nextButtonLabel);\n  }\n}\n\nfunction MatCalendar_ng_template_0_Template(rf, ctx) {}\n\nfunction MatCalendar_mat_clock_view_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-clock-view\", 6);\n    i0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_clock_view_2_Template_mat_clock_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.activeDate = $event;\n    })(\"currentViewChange\", function MatCalendar_mat_clock_view_2_Template_mat_clock_view_currentViewChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.currentView = $event;\n    })(\"selectedChange\", function MatCalendar_mat_clock_view_2_Template_mat_clock_view_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.setDate($event);\n    })(\"hourSelected\", function MatCalendar_mat_clock_view_2_Template_mat_clock_view_hourSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9._hourSelectedInClockView($event);\n    })(\"_userSelection\", function MatCalendar_mat_clock_view_2_Template_mat_clock_view__userSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10._timeSelectedInClockView($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"activeDate\", ctx_r1.activeDate)(\"selected\", ctx_r1.selected)(\"currentView\", ctx_r1.currentView)(\"selected\", ctx_r1.selected)(\"dateFilter\", ctx_r1.dateFilter)(\"dateClass\", ctx_r1.dateClass)(\"clockStep\", ctx_r1.clockStep)(\"twelveHour\", ctx_r1.twelveHour);\n  }\n}\n\nfunction MatCalendar_mat_month_view_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-month-view\", 7);\n    i0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_month_view_3_Template_mat_month_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.activeDate = $event;\n    })(\"_userSelection\", function MatCalendar_mat_month_view_3_Template_mat_month_view__userSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13._daySelected($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"activeDate\", ctx_r2.activeDate)(\"selected\", ctx_r2.selected)(\"dateFilter\", ctx_r2.dateFilter)(\"maxDate\", ctx_r2.maxDate)(\"minDate\", ctx_r2.minDate)(\"dateClass\", ctx_r2.dateClass)(\"comparisonStart\", ctx_r2.comparisonStart)(\"comparisonEnd\", ctx_r2.comparisonEnd);\n  }\n}\n\nfunction MatCalendar_mat_year_view_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-year-view\", 8);\n    i0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_year_view_4_Template_mat_year_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.activeDate = $event;\n    })(\"monthSelected\", function MatCalendar_mat_year_view_4_Template_mat_year_view_monthSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16._monthSelectedInYearView($event);\n    })(\"selectedChange\", function MatCalendar_mat_year_view_4_Template_mat_year_view_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.hasOutput(\"month\") ? ctx_r17._dateEmit($event) : ctx_r17._goToDateInView($event, \"month\");\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"activeDate\", ctx_r3.activeDate)(\"selected\", ctx_r3.selected)(\"dateFilter\", ctx_r3.dateFilter)(\"maxDate\", ctx_r3.maxDate)(\"minDate\", ctx_r3.minDate)(\"dateClass\", ctx_r3.dateClass);\n  }\n}\n\nfunction MatCalendar_mat_multi_year_view_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-multi-year-view\", 9);\n    i0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_multi_year_view_5_Template_mat_multi_year_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.activeDate = $event;\n    })(\"yearSelected\", function MatCalendar_mat_multi_year_view_5_Template_mat_multi_year_view_yearSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20._yearSelectedInMultiYearView($event);\n    })(\"selectedChange\", function MatCalendar_mat_multi_year_view_5_Template_mat_multi_year_view_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return ctx_r21.hasOutput(\"year\") ? ctx_r21._dateEmit($event) : ctx_r21._goToDateInView($event, \"year\");\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"yearsPerPage\", ctx_r4.yearsPerPage)(\"yearsPerRow\", ctx_r4.yearsPerRow)(\"activeDate\", ctx_r4.activeDate)(\"selected\", ctx_r4.selected)(\"dateFilter\", ctx_r4.dateFilter)(\"maxDate\", ctx_r4.maxDate)(\"minDate\", ctx_r4.minDate)(\"dateClass\", ctx_r4.dateClass);\n  }\n}\n\nfunction MatDatepickerContent_ng_template_2_Template(rf, ctx) {}\n\nconst _c6 = [\"button\"];\n\nfunction MatDatepickerToggle__svg_svg_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"svg\", 3);\n    i0.ɵɵelement(1, \"path\", 4);\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c7 = [[[\"\", \"matDatepickerToggleIcon\", \"\"]]];\nconst _c8 = [\"[matDatepickerToggleIcon]\"];\nconst _c9 = [[[\"input\", \"matStartDate\", \"\"]], [[\"input\", \"matEndDate\", \"\"]]];\nconst _c10 = [\"input[matStartDate]\", \"input[matEndDate]\"];\n\nfunction MatDatepickerActions_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c11 = [\"*\"];\nconst matDatepickerAnimations = {\n  /** Transforms the height of the datepicker's calendar. */\n  transformPanel: trigger('transformPanel', [state('void', style({\n    opacity: 0,\n    transform: 'scale(1, 0.8)'\n  })), transition('void => enter', animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({\n    opacity: 1,\n    transform: 'scale(1, 1)'\n  }))), transition('* => void', animate('100ms linear', style({\n    opacity: 0\n  })))]),\n\n  /** Fades in the content of the calendar. */\n  fadeInCalendar: trigger('fadeInCalendar', [state('void', style({\n    opacity: 0\n  })), state('enter', style({\n    opacity: 1\n  })), // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we\n  // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.\n  transition('void => *', animate('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))]),\n\n  /* Active control */\n  controlActive: trigger('controlActive', [transition('* => active', [animate('0.4s linear', keyframes([style({\n    transform: 'scale(0.9)'\n  }), style({\n    transform: 'scale(1.1)'\n  }), style({\n    transform: 'scale(1)'\n  })]))])])\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\n\nfunction createMissingDateImplError(provider) {\n  return Error(`MatDatepicker: No provider found for ${provider}. You must import one of the following ` + `modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a ` + `custom implementation.`);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Datepicker data that requires internationalization. */\n\n\nlet MatDatepickerIntl = /*#__PURE__*/(() => {\n  class MatDatepickerIntl {\n    constructor() {\n      /**\n       * Stream that emits whenever the labels here are changed. Use this to notify\n       * components if the labels have changed after initialization.\n       */\n      this.changes = new Subject();\n      /** A label for the calendar popup (used by screen readers). */\n\n      this.calendarLabel = 'Calendar';\n      /** A label for the button used to open the calendar popup (used by screen readers). */\n\n      this.openCalendarLabel = 'Open calendar';\n      /** Label for the button used to close the calendar popup. */\n\n      this.closeCalendarLabel = 'Close calendar';\n      /** A label for the previous month button (used by screen readers). */\n\n      this.prevMonthLabel = 'Previous month';\n      /** A label for the next month button (used by screen readers). */\n\n      this.nextMonthLabel = 'Next month';\n      /** A label for the previous year button (used by screen readers). */\n\n      this.prevYearLabel = 'Previous year';\n      /** A label for the next year button (used by screen readers). */\n\n      this.nextYearLabel = 'Next year';\n      /** A label for the previous multi-year button (used by screen readers). */\n\n      this.prevMultiYearLabel = 'Previous 20 years';\n      /** A label for the next multi-year button (used by screen readers). */\n\n      this.nextMultiYearLabel = 'Next 20 years';\n      /** A label for the 'AM' button (used by screen readers). */\n\n      this.setToAMLabel = 'Set date to AM';\n      /** A label for the 'PM' button (used by screen readers). */\n\n      this.setToPMLabel = 'Set date to PM';\n      /** A label for the 'switch to minute view' button (used by screen readers). */\n\n      this.switchToMinuteViewLabel = 'Change to minute view';\n      /** A label for the 'switch to hour view' button (used by screen readers). */\n\n      this.switchToHourViewLabel = 'Change to hour view';\n      /** A label for the 'switch to month view' button (used by screen readers). */\n\n      this.switchToMonthViewLabel = 'Change to month view';\n      /** A label for the 'switch to year view' button (used by screen readers). */\n\n      this.switchToYearViewLabel = 'Change to year view';\n      /** A label for the 'switch to years view' button (used by screen readers). */\n\n      this.switchToMultiYearViewLabel = 'Change to years view';\n    }\n    /** Formats a range of years. */\n\n\n    formatYearRange(start, end) {\n      return `${start} \\u2013 ${end}`;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerIntl.ɵfac = function MatDatepickerIntl_Factory(t) {\n    return new (t || MatDatepickerIntl)();\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerIntl.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MatDatepickerIntl,\n    factory: MatDatepickerIntl.ɵfac,\n    providedIn: 'root'\n  });\n  return MatDatepickerIntl;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst CLOCK_RADIUS = 50;\nconst CLOCK_INNER_RADIUS = 27.5;\nconst CLOCK_OUTER_RADIUS = 41.25;\nconst CLOCK_TICK_RADIUS = 7.0833;\n/**\n * A clock that is used as part of the datepicker.\n * @docs-private\n */\n\nlet MatClockView = /*#__PURE__*/(() => {\n  class MatClockView {\n    constructor(_changeDetectorRef, _element, _dateAdapter, _dateFormats) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._element = _element;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this.clockStep = 1;\n      this.twelveHour = false;\n      this.currentViewChange = new EventEmitter();\n      /** Emits when a new date is selected. */\n\n      this.selectedChange = new EventEmitter();\n      /** Emits when any date is selected. */\n\n      this._userSelection = new EventEmitter(); // Hours and Minutes representing the clock view.\n\n      this._hours = [];\n      this._minutes = [];\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n\n      this.mouseMoveListener = event => {\n        this._handleMousemove(event);\n      };\n\n      this.mouseUpListener = () => {\n        this._handleMouseup();\n      };\n    }\n    /**\n     * The time to display in this clock view. (the rest is ignored)\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      const oldActiveDate = this._activeDate;\n\n      const validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (oldActiveDate && this._dateAdapter.compareDate(oldActiveDate, this._activeDate)) {\n        this._init();\n      }\n    } // The currently selected date.\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    updateSize() {\n      const {\n        offsetWidth,\n        offsetHeight\n      } = this._element.nativeElement;\n      this._size = (offsetWidth < offsetHeight ? offsetWidth : offsetHeight) * 0.9;\n\n      this._changeDetectorRef.detectChanges();\n    }\n\n    get inHourView() {\n      return this.currentView === 'hour';\n    }\n\n    get _hand() {\n      this._selectedHour = this._dateAdapter.getHours(this.activeDate);\n      this._selectedMinute = this._dateAdapter.getMinutes(this.activeDate);\n      let radius = CLOCK_OUTER_RADIUS;\n      let deg = 0;\n\n      if (this.inHourView) {\n        const outer = this.twelveHour || this._selectedHour >= 0 && this._selectedHour < 12;\n        radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;\n        deg = Math.round(this._selectedHour * (360 / (24 / 2)));\n      } else {\n        deg = Math.round(this._selectedMinute * (360 / 60));\n      }\n\n      return {\n        transform: `rotate(${deg}deg)`,\n        height: `${radius}%`,\n        'margin-top': `${50 - radius}%`,\n        transition: this._draggingMouse ? 'none' : 'all 300ms ease'\n      };\n    }\n\n    ngAfterViewInit() {\n      this.updateSize();\n    }\n\n    ngAfterContentInit() {\n      this._init();\n    } // Handles mousedown events on the clock body.\n\n\n    _handleMousedown(event) {\n      this._draggingMouse = true;\n      document.addEventListener('mousemove', this.mouseMoveListener);\n      document.addEventListener('touchmove', this.mouseMoveListener);\n      document.addEventListener('mouseup', this.mouseUpListener);\n      document.addEventListener('touchend', this.mouseUpListener);\n      this.setTime(event);\n    }\n\n    _handleMousemove(event) {\n      event.preventDefault();\n      this.setTime(event);\n    }\n\n    _handleMouseup() {\n      this._draggingMouse = false;\n      document.removeEventListener('mousemove', this.mouseMoveListener);\n      document.removeEventListener('touchmove', this.mouseMoveListener);\n      document.removeEventListener('mouseup', this.mouseUpListener);\n      document.removeEventListener('touchend', this.mouseUpListener);\n\n      if (this.dateFilter && !this.dateFilter(this.activeDate, this.currentView)) {\n        return;\n      }\n\n      if (this.inHourView) {\n        // we refresh the valid minutes\n        this.currentViewChange.emit('minute');\n        this.selectedChange.emit(this.activeDate);\n\n        this._init();\n      } else {\n        this._userSelection.emit({\n          value: this.activeDate,\n          event\n        });\n      }\n    } // Initializes this clock view.\n\n\n    _init() {\n      this._hours.length = 0;\n      this._minutes.length = 0;\n\n      const hourNames = this._dateAdapter.getHourNames();\n\n      const minuteNames = this._dateAdapter.getMinuteNames();\n\n      if (this.twelveHour) {\n        this._anteMeridian = this._dateAdapter.getHours(this.activeDate) < 12;\n\n        for (let i = 0; i < hourNames.length / 2; i++) {\n          const radian = i / 6 * Math.PI;\n          const radius = CLOCK_OUTER_RADIUS;\n\n          const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), this._dateAdapter.getDate(this.activeDate), this._anteMeridian ? i : i + 12, 0, 0, 0);\n\n          this._hours.push({\n            value: this._anteMeridian ? i : i + 12,\n            displayValue: i === 0 ? hourNames[12] : hourNames[i],\n            enabled: !this.dateFilter || this.dateFilter(date, 'hour'),\n            cssClasses: this.dateClass ? this.dateClass(date, 'hour') : undefined,\n            top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,\n            left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS\n          });\n        }\n      } else {\n        for (let i = 0; i < hourNames.length; i++) {\n          const radian = i / 6 * Math.PI;\n          const outer = i > 0 && i < 13;\n          const radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;\n          const hour = i % 12 ? i : i === 0 ? 12 : 0;\n\n          const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), this._dateAdapter.getDate(this.activeDate), hour, 0, 0, 0);\n\n          this._hours.push({\n            value: hour,\n            displayValue: hourNames[hour],\n            enabled: !this.dateFilter || this.dateFilter(date, 'hour'),\n            cssClasses: this.dateClass ? this.dateClass(date, 'hour') : undefined,\n            top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,\n            left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS,\n            fontSize: i > 0 && i < 13 ? '' : '80%'\n          });\n        }\n      }\n\n      for (let i = 0; i < minuteNames.length; i += 5) {\n        const radian = i / 30 * Math.PI;\n\n        const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), this._dateAdapter.getDate(this.activeDate), this._dateAdapter.getHours(this.activeDate), i, 0, 0);\n\n        this._minutes.push({\n          value: i,\n          displayValue: i === 0 ? '00' : minuteNames[i],\n          enabled: !this.dateFilter || this.dateFilter(date, 'minute'),\n          cssClasses: this.dateClass ? this.dateClass(date, 'minute') : undefined,\n          top: CLOCK_RADIUS - Math.cos(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS,\n          left: CLOCK_RADIUS + Math.sin(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS\n        });\n      }\n\n      this._changeDetectorRef.markForCheck();\n    } // Set Time\n\n\n    setTime(event) {\n      const trigger = this._element.nativeElement;\n      const triggerRect = trigger.getBoundingClientRect();\n      const width = trigger.offsetWidth;\n      const height = trigger.offsetHeight;\n      const pageX = event.pageX !== undefined ? event.pageX : event.touches[0].pageX;\n      const pageY = event.pageY !== undefined ? event.pageY : event.touches[0].pageY;\n      const x = width / 2 - (pageX - triggerRect.left - window.pageXOffset);\n      const y = height / 2 - (pageY - triggerRect.top - window.pageYOffset);\n      const unit = Math.PI / (this.inHourView ? 6 : this.clockStep ? 30 / this.clockStep : 30);\n      const z = Math.sqrt(x * x + y * y);\n      const avg = (width * (CLOCK_OUTER_RADIUS / 100) + width * (CLOCK_INNER_RADIUS / 100)) / 2;\n      const outer = this.inHourView && z > avg - 16\n      /* button radius */\n      ;\n      let radian = Math.atan2(-x, y);\n\n      if (radian < 0) {\n        radian = Math.PI * 2 + radian;\n      }\n\n      let value = Math.round(radian / unit);\n\n      let date = this._dateAdapter.clone(this.activeDate);\n\n      if (this.inHourView) {\n        if (value === 12) {\n          value = 0;\n        }\n\n        value = this.twelveHour ? this._anteMeridian ? value : value + 12 : outer ? value : value + 12;\n        date = this._dateAdapter.setHours(date, value);\n      } else {\n        if (this.clockStep) {\n          value *= this.clockStep;\n        }\n\n        if (value === 60) {\n          value = 0;\n        }\n\n        date = this._dateAdapter.setMinutes(date, value);\n      } // validate if the resulting value is disabled and do not take action\n\n\n      if (this.dateFilter && !this.dateFilter(date, this.currentView)) {\n        return;\n      } // we don't want to re-render the clock\n\n\n      this._activeDate = date;\n      this.selectedChange.emit(this.activeDate);\n    }\n\n    _focusActiveCell() {}\n    /**\n     * @param obj The object to check.\n     * @returns The given object if it is both a date instance and valid, otherwise null.\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatClockView.ɵfac = function MatClockView_Factory(t) {\n    return new (t || MatClockView)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8));\n  };\n  /** @nocollapse */\n\n\n  MatClockView.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatClockView,\n    selectors: [[\"mat-clock-view\"]],\n    hostAttrs: [\"role\", \"clock\"],\n    hostBindings: function MatClockView_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function MatClockView_mousedown_HostBindingHandler($event) {\n          return ctx._handleMousedown($event);\n        })(\"resize\", function MatClockView_resize_HostBindingHandler() {\n          return ctx.updateSize();\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\",\n      clockStep: \"clockStep\",\n      twelveHour: \"twelveHour\",\n      currentView: \"currentView\"\n    },\n    outputs: {\n      currentViewChange: \"currentViewChange\",\n      selectedChange: \"selectedChange\",\n      _userSelection: \"_userSelection\"\n    },\n    exportAs: [\"matClockView\"],\n    decls: 7,\n    vars: 11,\n    consts: [[1, \"mat-clock\"], [1, \"mat-clock-center\"], [1, \"mat-clock-hand\", 3, \"ngStyle\"], [1, \"mat-clock-hours\"], [\"class\", \"mat-clock-cell\", 3, \"ngClass\", \"mat-clock-cell-selected\", \"mat-clock-cell-disabled\", \"top\", \"left\", \"fontSize\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-clock-minutes\"], [\"class\", \"mat-clock-cell\", 3, \"ngClass\", \"mat-clock-cell-selected\", \"mat-clock-cell-disabled\", \"top\", \"left\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-clock-cell\", 3, \"ngClass\"]],\n    template: function MatClockView_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelement(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵtemplate(4, MatClockView_div_4_Template, 2, 12, \"div\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"div\", 5);\n        i0.ɵɵtemplate(6, MatClockView_div_6_Template, 2, 10, \"div\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx._size, \"px\")(\"height\", ctx._size, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngStyle\", ctx._hand);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"active\", ctx.inHourView);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx._hours);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"active\", !ctx.inHourView);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx._minutes);\n      }\n    },\n    directives: [i4.NgStyle, i4.NgForOf, i4.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatClockView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An internal class that represents the data corresponding to a single calendar cell.\n * @docs-private\n */\n\n\nclass MatCalendarCell {\n  constructor(value, displayValue, ariaLabel, enabled, cssClasses = {}, compareValue = value, rawValue) {\n    this.value = value;\n    this.displayValue = displayValue;\n    this.ariaLabel = ariaLabel;\n    this.enabled = enabled;\n    this.cssClasses = cssClasses;\n    this.compareValue = compareValue;\n    this.rawValue = rawValue;\n  }\n\n}\n/**\n * An internal component used to display calendar data in a table.\n * @docs-private\n */\n\n\nlet MatCalendarBody = /*#__PURE__*/(() => {\n  class MatCalendarBody {\n    constructor(_elementRef, _ngZone) {\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      /** The number of columns in the table. */\n\n      this.numCols = 7;\n      /** The cell number of the active cell in the table. */\n\n      this.activeCell = 0;\n      /** Whether a range is being selected. */\n\n      this.isRange = false;\n      /**\n       * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\n       * maintained even as the table resizes.\n       */\n\n      this.cellAspectRatio = 1;\n      /** Start of the preview range. */\n\n      this.previewStart = null;\n      /** End of the preview range. */\n\n      this.previewEnd = null;\n      /** Emits when a new value is selected. */\n\n      this.selectedValueChange = new EventEmitter();\n      /** Emits when the preview has changed as a result of a user action. */\n\n      this.previewChange = new EventEmitter();\n      /**\n       * Event handler for when the user enters an element\n       * inside the calendar body (e.g. by hovering in or focus).\n       */\n\n      this._enterHandler = event => {\n        if (this._skipNextFocus && event.type === 'focus') {\n          this._skipNextFocus = false;\n          return;\n        } // We only need to hit the zone when we're selecting a range.\n\n\n        if (event.target && this.isRange) {\n          const cell = this._getCellFromElement(event.target);\n\n          if (cell) {\n            this._ngZone.run(() => this.previewChange.emit({\n              value: cell.enabled ? cell : null,\n              event\n            }));\n          }\n        }\n      };\n      /**\n       * Event handler for when the user's pointer leaves an element\n       * inside the calendar body (e.g. by hovering out or blurring).\n       */\n\n\n      this._leaveHandler = event => {\n        // We only need to hit the zone when we're selecting a range.\n        if (this.previewEnd !== null && this.isRange) {\n          // Only reset the preview end value when leaving cells. This looks better, because\n          // we have a gap between the cells and the rows and we don't want to remove the\n          // range just for it to show up again when the user moves a few pixels to the side.\n          if (event.target && isTableCell(event.target)) {\n            this._ngZone.run(() => this.previewChange.emit({\n              value: null,\n              event\n            }));\n          }\n        }\n      };\n\n      _ngZone.runOutsideAngular(() => {\n        const element = _elementRef.nativeElement;\n        element.addEventListener('mouseenter', this._enterHandler, true);\n        element.addEventListener('focus', this._enterHandler, true);\n        element.addEventListener('mouseleave', this._leaveHandler, true);\n        element.addEventListener('blur', this._leaveHandler, true);\n      });\n    }\n    /** Called when a cell is clicked. */\n\n\n    _cellClicked(cell, event) {\n      if (cell.enabled) {\n        this.selectedValueChange.emit({\n          value: cell.value,\n          event\n        });\n      }\n    }\n    /** Returns whether a cell should be marked as selected. */\n\n\n    _isSelected(value) {\n      return this.startValue === value || this.endValue === value;\n    }\n\n    ngOnChanges(changes) {\n      const columnChanges = changes['numCols'];\n      const {\n        rows,\n        numCols\n      } = this;\n\n      if (changes['rows'] || columnChanges) {\n        this._firstRowOffset = (rows === null || rows === void 0 ? void 0 : rows.length) && rows[0].length ? numCols - rows[0].length : 0;\n      }\n\n      if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {\n        this._cellPadding = `${50 * this.cellAspectRatio / numCols}%`;\n      }\n\n      if (columnChanges || !this._cellWidth) {\n        this._cellWidth = `${100 / numCols}%`;\n      }\n    }\n\n    ngOnDestroy() {\n      const element = this._elementRef.nativeElement;\n      element.removeEventListener('mouseenter', this._enterHandler, true);\n      element.removeEventListener('focus', this._enterHandler, true);\n      element.removeEventListener('mouseleave', this._leaveHandler, true);\n      element.removeEventListener('blur', this._leaveHandler, true);\n    }\n    /** Returns whether a cell is active. */\n\n\n    _isActiveCell(rowIndex, colIndex) {\n      let cellNumber = rowIndex * this.numCols + colIndex; // Account for the fact that the first row may not have as many cells.\n\n      if (rowIndex) {\n        cellNumber -= this._firstRowOffset;\n      }\n\n      return cellNumber == this.activeCell;\n    }\n    /** Focuses the active cell after the microtask queue is empty. */\n\n\n    _focusActiveCell(movePreview = true) {\n      this._ngZone.runOutsideAngular(() => {\n        this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n          const activeCell = this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');\n\n          if (activeCell) {\n            if (!movePreview) {\n              this._skipNextFocus = true;\n            }\n\n            activeCell.focus();\n          }\n        });\n      });\n    }\n    /** Gets whether a value is the start of the main range. */\n\n\n    _isRangeStart(value) {\n      return isStart(value, this.startValue, this.endValue);\n    }\n    /** Gets whether a value is the end of the main range. */\n\n\n    _isRangeEnd(value) {\n      return isEnd(value, this.startValue, this.endValue);\n    }\n    /** Gets whether a value is within the currently-selected range. */\n\n\n    _isInRange(value) {\n      return isInRange(value, this.startValue, this.endValue, this.isRange);\n    }\n    /** Gets whether a value is the start of the comparison range. */\n\n\n    _isComparisonStart(value) {\n      return isStart(value, this.comparisonStart, this.comparisonEnd);\n    }\n    /** Whether the cell is a start bridge cell between the main and comparison ranges. */\n\n\n    _isComparisonBridgeStart(value, rowIndex, colIndex) {\n      if (!this._isComparisonStart(value) || this._isRangeStart(value) || !this._isInRange(value)) {\n        return false;\n      }\n\n      let previousCell = this.rows[rowIndex][colIndex - 1];\n\n      if (!previousCell) {\n        const previousRow = this.rows[rowIndex - 1];\n        previousCell = previousRow && previousRow[previousRow.length - 1];\n      }\n\n      return previousCell && !this._isRangeEnd(previousCell.compareValue);\n    }\n    /** Whether the cell is an end bridge cell between the main and comparison ranges. */\n\n\n    _isComparisonBridgeEnd(value, rowIndex, colIndex) {\n      if (!this._isComparisonEnd(value) || this._isRangeEnd(value) || !this._isInRange(value)) {\n        return false;\n      }\n\n      let nextCell = this.rows[rowIndex][colIndex + 1];\n\n      if (!nextCell) {\n        const nextRow = this.rows[rowIndex + 1];\n        nextCell = nextRow && nextRow[0];\n      }\n\n      return nextCell && !this._isRangeStart(nextCell.compareValue);\n    }\n    /** Gets whether a value is the end of the comparison range. */\n\n\n    _isComparisonEnd(value) {\n      return isEnd(value, this.comparisonStart, this.comparisonEnd);\n    }\n    /** Gets whether a value is within the current comparison range. */\n\n\n    _isInComparisonRange(value) {\n      return isInRange(value, this.comparisonStart, this.comparisonEnd, this.isRange);\n    }\n    /**\n     * Gets whether a value is the same as the start and end of the comparison range.\n     * For context, the functions that we use to determine whether something is the start/end of\n     * a range don't allow for the start and end to be on the same day, because we'd have to use\n     * much more specific CSS selectors to style them correctly in all scenarios. This is fine for\n     * the regular range, because when it happens, the selected styles take over and still show where\n     * the range would've been, however we don't have these selected styles for a comparison range.\n     * This function is used to apply a class that serves the same purpose as the one for selected\n     * dates, but it only applies in the context of a comparison range.\n     */\n\n\n    _isComparisonIdentical(value) {\n      // Note that we don't need to null check the start/end\n      // here, because the `value` will always be defined.\n      return this.comparisonStart === this.comparisonEnd && value === this.comparisonStart;\n    }\n    /** Gets whether a value is the start of the preview range. */\n\n\n    _isPreviewStart(value) {\n      return isStart(value, this.previewStart, this.previewEnd);\n    }\n    /** Gets whether a value is the end of the preview range. */\n\n\n    _isPreviewEnd(value) {\n      return isEnd(value, this.previewStart, this.previewEnd);\n    }\n    /** Gets whether a value is inside the preview range. */\n\n\n    _isInPreview(value) {\n      return isInRange(value, this.previewStart, this.previewEnd, this.isRange);\n    }\n    /** Finds the MatCalendarCell that corresponds to a DOM node. */\n\n\n    _getCellFromElement(element) {\n      let cell;\n\n      if (isTableCell(element)) {\n        cell = element;\n      } else if (isTableCell(element.parentNode)) {\n        cell = element.parentNode;\n      }\n\n      if (cell) {\n        const row = cell.getAttribute('data-mat-row');\n        const col = cell.getAttribute('data-mat-col');\n\n        if (row && col) {\n          return this.rows[parseInt(row)][parseInt(col)];\n        }\n      }\n\n      return null;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatCalendarBody.ɵfac = function MatCalendarBody_Factory(t) {\n    return new (t || MatCalendarBody)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  MatCalendarBody.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatCalendarBody,\n    selectors: [[\"\", \"mat-calendar-body\", \"\"]],\n    hostAttrs: [\"role\", \"grid\", \"aria-readonly\", \"true\", 1, \"mat-calendar-body\"],\n    inputs: {\n      label: \"label\",\n      rows: \"rows\",\n      todayValue: \"todayValue\",\n      startValue: \"startValue\",\n      endValue: \"endValue\",\n      labelMinRequiredCells: \"labelMinRequiredCells\",\n      numCols: \"numCols\",\n      activeCell: \"activeCell\",\n      isRange: \"isRange\",\n      cellAspectRatio: \"cellAspectRatio\",\n      comparisonStart: \"comparisonStart\",\n      comparisonEnd: \"comparisonEnd\",\n      previewStart: \"previewStart\",\n      previewEnd: \"previewEnd\"\n    },\n    outputs: {\n      selectedValueChange: \"selectedValueChange\",\n      previewChange: \"previewChange\"\n    },\n    exportAs: [\"matCalendarBody\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c0,\n    decls: 1,\n    vars: 1,\n    consts: [[\"role\", \"row\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"row\"], [\"aria-hidden\", \"true\", \"class\", \"mat-calendar-body-label\", 3, \"paddingTop\", \"paddingBottom\", 4, \"ngIf\"], [\"role\", \"gridcell\", \"class\", \"mat-calendar-body-cell\", 3, \"ngClass\", \"tabindex\", \"mat-calendar-body-disabled\", \"mat-calendar-body-active\", \"mat-calendar-body-range-start\", \"mat-calendar-body-range-end\", \"mat-calendar-body-in-range\", \"mat-calendar-body-comparison-bridge-start\", \"mat-calendar-body-comparison-bridge-end\", \"mat-calendar-body-comparison-start\", \"mat-calendar-body-comparison-end\", \"mat-calendar-body-in-comparison-range\", \"mat-calendar-body-preview-start\", \"mat-calendar-body-preview-end\", \"mat-calendar-body-in-preview\", \"width\", \"paddingTop\", \"paddingBottom\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\", 1, \"mat-calendar-body-label\"], [\"role\", \"gridcell\", 1, \"mat-calendar-body-cell\", 3, \"ngClass\", \"tabindex\", \"click\"], [1, \"mat-calendar-body-cell-content\", \"mat-focus-indicator\"], [1, \"mat-calendar-body-cell-preview\"]],\n    template: function MatCalendarBody_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, MatCalendarBody_tr_0_Template, 3, 2, \"tr\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.rows);\n      }\n    },\n    directives: [i4.NgForOf, i4.NgIf, i4.NgClass],\n    styles: [\".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.7142857143%;padding-right:4.7142857143%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:none;cursor:pointer}.mat-calendar-body-cell:before,.mat-calendar-body-cell:after,.mat-calendar-body-cell-preview{content:\\\"\\\";position:absolute;top:5%;left:0;z-index:0;box-sizing:border-box;height:90%;width:100%}.mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range):before,.mat-calendar-body-range-start:after,.mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start):before,.mat-calendar-body-comparison-start:after,.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{left:5%;width:95%;border-top-left-radius:999px;border-bottom-left-radius:999px}[dir=rtl] .mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range):before,[dir=rtl] .mat-calendar-body-range-start:after,[dir=rtl] .mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start):before,[dir=rtl] .mat-calendar-body-comparison-start:after,[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{left:0;border-radius:0 999px 999px 0}.mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range):before,.mat-calendar-body-range-end:after,.mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end):before,.mat-calendar-body-comparison-end:after,.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{width:95%;border-top-right-radius:999px;border-bottom-right-radius:999px}[dir=rtl] .mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range):before,[dir=rtl] .mat-calendar-body-range-end:after,[dir=rtl] .mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end):before,[dir=rtl] .mat-calendar-body-comparison-end:after,[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{left:5%;border-radius:999px 0 0 999px}[dir=rtl] .mat-calendar-body-comparison-bridge-start.mat-calendar-body-range-end:after,[dir=rtl] .mat-calendar-body-comparison-bridge-end.mat-calendar-body-range-start:after{width:95%;border-top-right-radius:999px;border-bottom-right-radius:999px}.mat-calendar-body-comparison-start.mat-calendar-body-range-end:after,[dir=rtl] .mat-calendar-body-comparison-start.mat-calendar-body-range-end:after,.mat-calendar-body-comparison-end.mat-calendar-body-range-start:after,[dir=rtl] .mat-calendar-body-comparison-end.mat-calendar-body-range-start:after{width:90%}.mat-calendar-body-in-preview .mat-calendar-body-cell-preview{border-top:dashed 1px;border-bottom:dashed 1px}.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:dashed 1px}[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:0;border-right:dashed 1px}.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:dashed 1px}[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:0;border-left:dashed 1px}.mat-calendar-body-disabled{cursor:default}.cdk-high-contrast-active .mat-calendar-body-disabled{opacity:.5}.mat-calendar-body-cell-content{top:5%;left:5%;z-index:1;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}.mat-calendar-body-cell-content.mat-focus-indicator{position:absolute}.cdk-high-contrast-active .mat-calendar-body-cell-content{border:none}.mat-datepicker-dialog .mat-dialog-container{position:relative;overflow:visible}.cdk-high-contrast-active .mat-datepicker-popup:not(:empty),.cdk-high-contrast-active .mat-calendar-body-selected{outline:solid 1px}.cdk-high-contrast-active .mat-calendar-body-today{outline:dotted 1px}.cdk-high-contrast-active .cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-high-contrast-active .cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}[dir=rtl] .mat-calendar-body-label{text-align:right}@media (hover: none){.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){background-color:transparent}}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCalendarBody;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Checks whether a node is a table cell element. */\n\n\nfunction isTableCell(node) {\n  return node.nodeName === 'TD';\n}\n/** Checks whether a value is the start of a range. */\n\n\nfunction isStart(value, start, end) {\n  return end !== null && start !== end && value < end && value === start;\n}\n/** Checks whether a value is the end of a range. */\n\n\nfunction isEnd(value, start, end) {\n  return start !== null && start !== end && value >= start && value === end;\n}\n/** Checks whether a value is inside of a range. */\n\n\nfunction isInRange(value, start, end, rangeEnabled) {\n  return rangeEnabled && start !== null && end !== null && start !== end && value >= start && value <= end;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** A class representing a range of dates. */\n\n\nclass DateRange {\n  constructor(\n  /** The start date of the range. */\n  start,\n  /** The end date of the range. */\n  end) {\n    this.start = start;\n    this.end = end;\n  }\n\n}\n/** A selection model containing a date selection. */\n// @dynamic\n\n\nlet MatDateSelectionModel = /*#__PURE__*/(() => {\n  class MatDateSelectionModel {\n    constructor(\n    /** The current selection. */\n    selection, _adapter) {\n      this.selection = selection;\n      this._adapter = _adapter;\n      this._selectionChanged = new Subject();\n      /** Emits when the selection has changed. */\n\n      this.selectionChanged = this._selectionChanged;\n      this.selection = selection;\n    }\n    /**\n     * Updates the current selection in the model.\n     * @param value New selection that should be assigned.\n     * @param source Object that triggered the selection change.\n     */\n\n\n    updateSelection(value, source) {\n      this.selection = value;\n\n      this._selectionChanged.next({\n        selection: value,\n        source\n      });\n    }\n\n    ngOnDestroy() {\n      this._selectionChanged.complete();\n    }\n\n    _isValidDateInstance(date) {\n      return this._adapter.isDateInstance(date) && this._adapter.isValid(date);\n    }\n    /**\n     * Clones the selection model.\n     * @deprecated To be turned into an abstract method.\n     * @breaking-change 12.0.0\n     */\n\n\n    clone() {\n      if (isDevMode()) {\n        throw Error('Not implemented');\n      }\n\n      return null;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDateSelectionModel.ɵfac = function MatDateSelectionModel_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n  /** @nocollapse */\n\n\n  MatDateSelectionModel.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDateSelectionModel\n  });\n  return MatDateSelectionModel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**  A selection model that contains a single date. */\n\n\nlet MatSingleDateSelectionModel = /*#__PURE__*/(() => {\n  class MatSingleDateSelectionModel extends MatDateSelectionModel {\n    constructor(adapter) {\n      super(null, adapter);\n    }\n    /**\n     * Adds a date to the current selection. In the case of a single date selection, the added date\n     * simply overwrites the previous selection\n     */\n\n\n    add(date) {\n      super.updateSelection(date, this);\n    }\n    /** Adds a date as pending to update if the user selects the date partially. */\n\n\n    queue(date) {\n      this.queuedValue = date;\n    }\n\n    processQueue() {\n      if (this.queuedValue) {\n        this.updateSelection(this.queuedValue, this);\n      }\n    }\n    /** Checks whether the current selection is valid. */\n\n\n    isValid() {\n      return this.selection != null && this._isValidDateInstance(this.selection);\n    }\n    /**\n     * Checks whether the current selection is complete. In the case of a single date selection, this\n     * is true if the current selection is not null.\n     */\n\n\n    isComplete() {\n      return this.selection != null;\n    }\n    /** Clones the selection model. */\n\n\n    clone() {\n      const clone = new MatSingleDateSelectionModel(this._adapter);\n      clone.updateSelection(this.selection, this);\n\n      if (this.queuedValue) {\n        clone.queue(this.queuedValue);\n      }\n\n      return clone;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatSingleDateSelectionModel.ɵfac = function MatSingleDateSelectionModel_Factory(t) {\n    return new (t || MatSingleDateSelectionModel)(i0.ɵɵinject(i1.DateAdapter));\n  };\n  /** @nocollapse */\n\n\n  MatSingleDateSelectionModel.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MatSingleDateSelectionModel,\n    factory: MatSingleDateSelectionModel.ɵfac\n  });\n  return MatSingleDateSelectionModel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**  A selection model that contains a date range. */\n\n\nlet MatRangeDateSelectionModel = /*#__PURE__*/(() => {\n  class MatRangeDateSelectionModel extends MatDateSelectionModel {\n    constructor(adapter) {\n      super(new DateRange(null, null), adapter);\n    }\n    /**\n     * Adds a date to the current selection. In the case of a date range selection, the added date\n     * fills in the next `null` value in the range. If both the start and the end already have a date,\n     * the selection is reset so that the given date is the new `start` and the `end` is null.\n     */\n\n\n    add(date) {\n      let {\n        start,\n        end\n      } = this.selection;\n\n      if (start == null) {\n        start = date;\n      } else if (end == null) {\n        end = date;\n      } else {\n        start = date;\n        end = null;\n      }\n\n      super.updateSelection(new DateRange(start, end), this);\n    }\n\n    queue(date) {}\n\n    processQueue() {}\n    /** Checks whether the current selection is valid. */\n\n\n    isValid() {\n      const {\n        start,\n        end\n      } = this.selection; // Empty ranges are valid.\n\n      if (start == null && end == null) {\n        return true;\n      } // Complete ranges are only valid if both dates are valid and the start is before the end.\n\n\n      if (start != null && end != null) {\n        return this._isValidDateInstance(start) && this._isValidDateInstance(end) && this._adapter.compareDate(start, end) <= 0;\n      } // Partial ranges are valid if the start/end is valid.\n\n\n      return (start == null || this._isValidDateInstance(start)) && (end == null || this._isValidDateInstance(end));\n    }\n    /**\n     * Checks whether the current selection is complete. In the case of a date range selection, this\n     * is true if the current selection has a non-null `start` and `end`.\n     */\n\n\n    isComplete() {\n      return this.selection.start != null && this.selection.end != null;\n    }\n    /** Clones the selection model. */\n\n\n    clone() {\n      const clone = new MatRangeDateSelectionModel(this._adapter);\n      clone.updateSelection(this.selection, this);\n      return clone;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatRangeDateSelectionModel.ɵfac = function MatRangeDateSelectionModel_Factory(t) {\n    return new (t || MatRangeDateSelectionModel)(i0.ɵɵinject(i1.DateAdapter));\n  };\n  /** @nocollapse */\n\n\n  MatRangeDateSelectionModel.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MatRangeDateSelectionModel,\n    factory: MatRangeDateSelectionModel.ɵfac\n  });\n  return MatRangeDateSelectionModel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @docs-private */\n\n\nfunction MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY(parent, adapter) {\n  return parent || new MatSingleDateSelectionModel(adapter);\n}\n/** Used to provide a single selection model to a component. */\n\n\nconst MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER = {\n  provide: MatDateSelectionModel,\n  deps: [[new Optional(), new SkipSelf(), MatDateSelectionModel], DateAdapter],\n  useFactory: MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY\n};\n/** @docs-private */\n\nfunction MAT_RANGE_DATE_SELECTION_MODEL_FACTORY(parent, adapter) {\n  return parent || new MatRangeDateSelectionModel(adapter);\n}\n/** Used to provide a range selection model to a component. */\n\n\nconst MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER = {\n  provide: MatDateSelectionModel,\n  deps: [[new Optional(), new SkipSelf(), MatDateSelectionModel], DateAdapter],\n  useFactory: MAT_RANGE_DATE_SELECTION_MODEL_FACTORY\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used to customize the date range selection behavior. */\n\nconst MAT_DATE_RANGE_SELECTION_STRATEGY = new InjectionToken('MAT_DATE_RANGE_SELECTION_STRATEGY');\n/** Provides the default date range selection behavior. */\n\nlet DefaultMatCalendarRangeStrategy = /*#__PURE__*/(() => {\n  class DefaultMatCalendarRangeStrategy {\n    constructor(_dateAdapter) {\n      this._dateAdapter = _dateAdapter;\n    }\n\n    selectionFinished(date, currentRange) {\n      let {\n        start,\n        end\n      } = currentRange;\n\n      if (start == null) {\n        start = date;\n      } else if (end == null && date && this._dateAdapter.compareDate(date, start) >= 0) {\n        end = date;\n      } else {\n        start = date;\n        end = null;\n      }\n\n      return new DateRange(start, end);\n    }\n\n    createPreview(activeDate, currentRange) {\n      let start = null;\n      let end = null;\n\n      if (currentRange.start && !currentRange.end && activeDate) {\n        start = currentRange.start;\n        end = activeDate;\n      }\n\n      return new DateRange(start, end);\n    }\n\n  }\n\n  /** @nocollapse */\n  DefaultMatCalendarRangeStrategy.ɵfac = function DefaultMatCalendarRangeStrategy_Factory(t) {\n    return new (t || DefaultMatCalendarRangeStrategy)(i0.ɵɵinject(i1.DateAdapter));\n  };\n  /** @nocollapse */\n\n\n  DefaultMatCalendarRangeStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultMatCalendarRangeStrategy,\n    factory: DefaultMatCalendarRangeStrategy.ɵfac\n  });\n  return DefaultMatCalendarRangeStrategy;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @docs-private */\n\n\nfunction MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY(parent, adapter) {\n  return parent || new DefaultMatCalendarRangeStrategy(adapter);\n}\n/** @docs-private */\n\n\nconst MAT_CALENDAR_RANGE_STRATEGY_PROVIDER = {\n  provide: MAT_DATE_RANGE_SELECTION_STRATEGY,\n  deps: [[new Optional(), new SkipSelf(), MAT_DATE_RANGE_SELECTION_STRATEGY], DateAdapter],\n  useFactory: MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst DAYS_PER_WEEK = 7;\n/**\n * An internal component used to display a single month in the datepicker.\n * @docs-private\n */\n\nlet MatMonthView = /*#__PURE__*/(() => {\n  class MatMonthView {\n    constructor(_changeDetectorRef, _dateFormats, _dateAdapter, _dir, _rangeStrategy) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateFormats = _dateFormats;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._rangeStrategy = _rangeStrategy;\n      this._rerenderSubscription = Subscription.EMPTY;\n      /** Emits when a new date is selected. */\n\n      this.selectedChange = new EventEmitter();\n      /** Emits when any date is selected. */\n\n      this._userSelection = new EventEmitter();\n      /** Emits when any date is activated. */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (isDevMode()) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\n     * The date to display in this month view (everything other than the month and year is ignored).\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      const oldActiveDate = this._activeDate;\n\n      const validDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\n        this._init();\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n\n      this._setRanges(this._selected);\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(() => this._init());\n    }\n\n    ngOnChanges(changes) {\n      const comparisonChange = changes['comparisonStart'] || changes['comparisonEnd'];\n\n      if (comparisonChange && !comparisonChange.firstChange) {\n        this._setRanges(this.selected);\n      }\n    }\n\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    /** Handles when a new date is selected. */\n\n\n    _dateSelected(event) {\n      const date = event.value;\n\n      const selectedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), date, this._dateAdapter.getHours(this.activeDate), this._dateAdapter.getMinutes(this.activeDate), this._dateAdapter.getSeconds(this.activeDate), this._dateAdapter.getMilliseconds(this.activeDate));\n\n      let rangeStartDate;\n      let rangeEndDate;\n\n      if (this._selected instanceof DateRange) {\n        rangeStartDate = this._getDateInCurrentMonth(this._selected.start);\n        rangeEndDate = this._getDateInCurrentMonth(this._selected.end);\n      } else {\n        rangeStartDate = rangeEndDate = this._getDateInCurrentMonth(this._selected);\n      }\n\n      if (rangeStartDate !== date || rangeEndDate !== date) {\n        this.selectedChange.emit(selectedDate);\n      }\n\n      this._userSelection.emit({\n        value: selectedDate,\n        event: event.event\n      });\n\n      this._previewStart = this._previewEnd = null;\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Handles keydown events on the calendar body when calendar is in month view. */\n\n\n    _handleCalendarBodyKeydown(event) {\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n      const oldActiveDate = this._activeDate;\n\n      const isRtl = this._isRtl();\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\n          break;\n\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\n          break;\n\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\n          break;\n\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\n          break;\n\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\n          break;\n\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, this._dateAdapter.getNumDaysInMonth(this._activeDate) - this._dateAdapter.getDate(this._activeDate));\n          break;\n\n        case PAGE_UP:\n          this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, -1) : this._dateAdapter.addCalendarMonths(this._activeDate, -1);\n          break;\n\n        case PAGE_DOWN:\n          this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, 1) : this._dateAdapter.addCalendarMonths(this._activeDate, 1);\n          break;\n\n        case ENTER:\n        case SPACE:\n          if (!this.dateFilter || this.dateFilter(this._activeDate, 'day')) {\n            this._dateSelected({\n              value: this._dateAdapter.getDate(this._activeDate),\n              event\n            }); // Prevent unexpected default actions such as form submission.\n\n\n            event.preventDefault();\n          }\n\n          return;\n\n        case ESCAPE:\n          // Abort the current range selection if the user presses escape mid-selection.\n          if (this._previewEnd != null && !hasModifierKey(event)) {\n            this._previewStart = this._previewEnd = null;\n            this.selectedChange.emit(null);\n\n            this._userSelection.emit({\n              value: null,\n              event\n            });\n\n            event.preventDefault();\n            event.stopPropagation(); // Prevents the overlay from closing.\n          }\n\n          return;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n\n      this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /** Initializes this month view. */\n\n\n    _init() {\n      this._setRanges(this.selected);\n\n      this._todayDate = this._getCellCompareValue(this._dateAdapter.today());\n      this._monthLabel = this._dateFormats.display.monthLabel ? this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthLabel) : this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase();\n\n      let firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\n\n      this._firstWeekOffset = (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) - this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\n\n      this._initWeekdays();\n\n      this._createWeekCells();\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Focuses the active cell after the microtask queue is empty. */\n\n\n    _focusActiveCell(movePreview) {\n      this._matCalendarBody._focusActiveCell(movePreview);\n    }\n    /** Called when the user has activated a new cell and the preview needs to be updated. */\n\n\n    _previewChanged({\n      event,\n      value: cell\n    }) {\n      if (this._rangeStrategy) {\n        // We can assume that this will be a range, because preview\n        // events aren't fired for single date selections.\n        const value = cell ? cell.rawValue : null;\n\n        const previewRange = this._rangeStrategy.createPreview(value, this.selected, event);\n\n        this._previewStart = this._getCellCompareValue(previewRange.start);\n        this._previewEnd = this._getCellCompareValue(previewRange.end); // Note that here we need to use `detectChanges`, rather than `markForCheck`, because\n        // the way `_focusActiveCell` is set up at the moment makes it fire at the wrong time\n        // when navigating one month back using the keyboard which will cause this handler\n        // to throw a \"changed after checked\" error when updating the preview state.\n\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /** Initializes the weekdays. */\n\n\n    _initWeekdays() {\n      const firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\n\n      const narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\n\n      const longWeekdays = this._dateAdapter.getDayOfWeekNames('long'); // Rotate the labels for days of the week based on the configured first day of the week.\n\n\n      let weekdays = longWeekdays.map((long, i) => {\n        return {\n          long,\n          narrow: narrowWeekdays[i]\n        };\n      });\n      this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n    }\n    /** Creates MatCalendarCells for the dates in this month. */\n\n\n    _createWeekCells() {\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\n\n      const dateNames = this._dateAdapter.getDateNames();\n\n      this._weeks = [[]];\n\n      for (let i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\n        if (cell == DAYS_PER_WEEK) {\n          this._weeks.push([]);\n\n          cell = 0;\n        }\n\n        const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\n\n        const enabled = this._shouldEnableDate(date);\n\n        const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\n\n        const cellClasses = this.dateClass ? this.dateClass(date, 'month') : undefined;\n\n        this._weeks[this._weeks.length - 1].push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses, this._getCellCompareValue(date), date));\n      }\n    }\n    /** Date filter for the month */\n\n\n    _shouldEnableDate(date) {\n      return !!date && (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) && (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0) && (!this.dateFilter || this.dateFilter(date, 'day'));\n    }\n    /**\n     * Gets the date in this month that the given Date falls on.\n     * Returns null if the given Date is in another month.\n     */\n\n\n    _getDateInCurrentMonth(date) {\n      return date && this._hasSameMonthAndYear(date, this.activeDate) ? this._dateAdapter.getDate(date) : null;\n    }\n    /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */\n\n\n    _hasSameMonthAndYear(d1, d2) {\n      return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) && this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\n    }\n    /** Gets the value that will be used to one cell to another. */\n\n\n    _getCellCompareValue(date) {\n      if (date) {\n        // We use the time since the Unix epoch to compare dates in this view, rather than the\n        // cell values, because we need to support ranges that span across multiple months/years.\n        const year = this._dateAdapter.getYear(date);\n\n        const month = this._dateAdapter.getMonth(date);\n\n        const day = this._dateAdapter.getDate(date);\n\n        return new Date(year, month, day).getTime();\n      }\n\n      return null;\n    }\n    /** Determines whether the user has the RTL layout direction. */\n\n\n    _isRtl() {\n      var _a;\n\n      return ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) === 'rtl';\n    }\n    /** Sets the current range based on a model value. */\n\n\n    _setRanges(selectedValue) {\n      if (selectedValue instanceof DateRange) {\n        this._rangeStart = this._getCellCompareValue(selectedValue.start);\n        this._rangeEnd = this._getCellCompareValue(selectedValue.end);\n        this._isRange = true;\n      } else {\n        this._rangeStart = this._rangeEnd = this._getCellCompareValue(selectedValue);\n        this._isRange = false;\n      }\n\n      this._comparisonRangeStart = this._getCellCompareValue(this.comparisonStart);\n      this._comparisonRangeEnd = this._getCellCompareValue(this.comparisonEnd);\n    }\n\n  }\n\n  /** @nocollapse */\n  MatMonthView.ɵfac = function MatMonthView_Factory(t) {\n    return new (t || MatMonthView)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(i2.Directionality, 8), i0.ɵɵdirectiveInject(MAT_DATE_RANGE_SELECTION_STRATEGY, 8));\n  };\n  /** @nocollapse */\n\n\n  MatMonthView.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatMonthView,\n    selectors: [[\"mat-month-view\"]],\n    viewQuery: function MatMonthView_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(MatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\",\n      comparisonStart: \"comparisonStart\",\n      comparisonEnd: \"comparisonEnd\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      _userSelection: \"_userSelection\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"matMonthView\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 7,\n    vars: 13,\n    consts: [[\"role\", \"presentation\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"scope\", \"col\", 4, \"ngFor\", \"ngForOf\"], [\"colspan\", \"7\", \"aria-hidden\", \"true\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"label\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"comparisonStart\", \"comparisonEnd\", \"previewStart\", \"previewEnd\", \"isRange\", \"labelMinRequiredCells\", \"activeCell\", \"selectedValueChange\", \"previewChange\", \"keydown\"], [\"scope\", \"col\"]],\n    template: function MatMonthView_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"table\", 0);\n        i0.ɵɵelementStart(1, \"thead\", 1);\n        i0.ɵɵelementStart(2, \"tr\");\n        i0.ɵɵtemplate(3, MatMonthView_th_3_Template, 2, 2, \"th\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"tr\");\n        i0.ɵɵelement(5, \"th\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"tbody\", 4);\n        i0.ɵɵlistener(\"selectedValueChange\", function MatMonthView_Template_tbody_selectedValueChange_6_listener($event) {\n          return ctx._dateSelected($event);\n        })(\"previewChange\", function MatMonthView_Template_tbody_previewChange_6_listener($event) {\n          return ctx._previewChanged($event);\n        })(\"keydown\", function MatMonthView_Template_tbody_keydown_6_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx._weekdays);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"label\", ctx._monthLabel)(\"rows\", ctx._weeks)(\"todayValue\", ctx._todayDate)(\"startValue\", ctx._rangeStart)(\"endValue\", ctx._rangeEnd)(\"comparisonStart\", ctx._comparisonRangeStart)(\"comparisonEnd\", ctx._comparisonRangeEnd)(\"previewStart\", ctx._previewStart)(\"previewEnd\", ctx._previewEnd)(\"isRange\", ctx._isRange)(\"labelMinRequiredCells\", 3)(\"activeCell\", ctx._dateAdapter.getDate(ctx.activeDate) - 1);\n      }\n    },\n    directives: [i4.NgForOf, MatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatMonthView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An internal component used to display a year selector in the datepicker.\n * @docs-private\n */\n\n\nlet MatMultiYearView = /*#__PURE__*/(() => {\n  class MatMultiYearView {\n    constructor(_changeDetectorRef, _dateAdapter, _dir) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._rerenderSubscription = Subscription.EMPTY;\n      /** consts moved as inputs */\n\n      this.yearsPerPage = 24;\n      this.yearsPerRow = 4;\n      /** Emits when a new year is selected. */\n\n      this.selectedChange = new EventEmitter();\n      /** Emits the selected year. This doesn't imply a change on the selected date */\n\n      this.yearSelected = new EventEmitter();\n      /** Emits when any date is activated. */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter && isDevMode()) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /** The date to display in this multi-year view (everything other than the year is ignored). */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n\n      const validDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate, this.yearsPerPage)) {\n        this._init();\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n\n      this._setSelectedYear(value);\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(() => this._init());\n    }\n\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    /** Initializes this multi-year view. */\n\n\n    _init() {\n      this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today()); // We want a range years such that we maximize the number of\n      // enabled dates visible at once. This prevents issues where the minimum year\n      // is the last item of a page OR the maximum year is the first item of a page.\n      // The offset from the active year to the \"slot\" for the starting year is the\n      // *actual* first rendered year in the multi-year view.\n\n      const activeYear = this._dateAdapter.getYear(this._activeDate);\n\n      const minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate, this.yearsPerPage);\n      this._years = [];\n\n      for (let i = 0, row = []; i < this.yearsPerPage; i++) {\n        row.push(minYearOfPage + i);\n\n        if (row.length == this.yearsPerRow) {\n          this._years.push(row.map(year => this._createCellForYear(year)));\n\n          row = [];\n        }\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Handles when a new year is selected. */\n\n\n    _yearSelected(event) {\n      const year = event.value;\n\n      const month = this._dateAdapter.getMonth(this.activeDate);\n\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));\n\n      const day = Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth);\n\n      const activeDate = this._dateAdapter.createDate(year, month, day, this._dateAdapter.getHours(this.activeDate), this._dateAdapter.getMinutes(this.activeDate), this._dateAdapter.getSeconds(this.activeDate), this._dateAdapter.getMilliseconds(this.activeDate));\n\n      this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));\n      this.selectedChange.emit(activeDate);\n    }\n    /** Handles keydown events on the calendar body when calendar is in multi-year view. */\n\n\n    _handleCalendarBodyKeydown(event) {\n      const oldActiveDate = this._activeDate;\n\n      const isRtl = this._isRtl();\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\n          break;\n\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\n          break;\n\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -this.yearsPerRow);\n          break;\n\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, this.yearsPerRow);\n          break;\n\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate, this.yearsPerPage));\n          break;\n\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, this.yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate, this.yearsPerPage) - 1);\n          break;\n\n        case PAGE_UP:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -this.yearsPerPage * 10 : -this.yearsPerPage);\n          break;\n\n        case PAGE_DOWN:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? this.yearsPerPage * 10 : this.yearsPerPage);\n          break;\n\n        case ENTER:\n        case SPACE:\n          this._yearSelected({\n            value: this._dateAdapter.getYear(this._activeDate),\n            event\n          });\n\n          break;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n\n      this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n\n    _getActiveCell() {\n      return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate, this.yearsPerPage);\n    }\n    /** Focuses the active cell after the microtask queue is empty. */\n\n\n    _focusActiveCell() {\n      this._matCalendarBody._focusActiveCell();\n    }\n    /** Creates an MatCalendarCell for the given year. */\n\n\n    _createCellForYear(year) {\n      const date = this._dateAdapter.createDate(year, 0, 1);\n\n      const yearName = this._dateAdapter.getYearName(date);\n\n      const cellClasses = this.dateClass ? this.dateClass(date, 'multi-year') : undefined;\n      return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year), cellClasses);\n    }\n    /** Whether the given year is enabled. */\n\n\n    _shouldEnableYear(year) {\n      // disable if the year is greater than maxDate lower than minDate\n      if (year === undefined || year === null || this.maxDate && year > this._dateAdapter.getYear(this.maxDate) || this.minDate && year < this._dateAdapter.getYear(this.minDate)) {\n        return false;\n      } // enable if it reaches here and there's no filter defined\n\n\n      if (!this.dateFilter) {\n        return true;\n      }\n\n      const firstOfYear = this._dateAdapter.createDate(year, 0, 1); // If any date in the year is enabled count the year as enabled.\n\n\n      for (let date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date, 'year')) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /** Determines whether the user has the RTL layout direction. */\n\n\n    _isRtl() {\n      var _a;\n\n      return ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) === 'rtl';\n    }\n    /** Sets the currently-highlighted year based on a model value. */\n\n\n    _setSelectedYear(value) {\n      this._selectedYear = null;\n\n      if (value instanceof DateRange) {\n        const displayValue = value.start || value.end;\n\n        if (displayValue) {\n          this._selectedYear = this._dateAdapter.getYear(displayValue);\n        }\n      } else if (value) {\n        this._selectedYear = this._dateAdapter.getYear(value);\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  MatMultiYearView.ɵfac = function MatMultiYearView_Factory(t) {\n    return new (t || MatMultiYearView)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(i2.Directionality, 8));\n  };\n  /** @nocollapse */\n\n\n  MatMultiYearView.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatMultiYearView,\n    selectors: [[\"mat-multi-year-view\"]],\n    viewQuery: function MatMultiYearView_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(MatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      yearsPerPage: \"yearsPerPage\",\n      yearsPerRow: \"yearsPerRow\",\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      yearSelected: \"yearSelected\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"matMultiYearView\"],\n    decls: 5,\n    vars: 7,\n    consts: [[\"role\", \"presentation\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"numCols\", \"cellAspectRatio\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function MatMultiYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"table\", 0);\n        i0.ɵɵelementStart(1, \"thead\", 1);\n        i0.ɵɵelementStart(2, \"tr\");\n        i0.ɵɵelement(3, \"th\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"tbody\", 3);\n        i0.ɵɵlistener(\"selectedValueChange\", function MatMultiYearView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._yearSelected($event);\n        })(\"keydown\", function MatMultiYearView_Template_tbody_keydown_4_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"rows\", ctx._years)(\"todayValue\", ctx._todayYear)(\"startValue\", ctx._selectedYear)(\"endValue\", ctx._selectedYear)(\"numCols\", ctx.yearsPerRow)(\"cellAspectRatio\", ctx.yearsPerRow / 7)(\"activeCell\", ctx._getActiveCell());\n      }\n    },\n    directives: [MatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatMultiYearView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate, yearsPerPage) {\n  const year1 = dateAdapter.getYear(date1);\n  const year2 = dateAdapter.getYear(date2);\n  const startingYear = getStartingYear(dateAdapter, minDate, maxDate, yearsPerPage);\n  return Math.floor((year1 - startingYear) / yearsPerPage) === Math.floor((year2 - startingYear) / yearsPerPage);\n}\n/**\n * When the multi-year view is first opened, the active year will be in view.\n * So we compute how many years are between the active year and the *slot* where our\n * \"startingYear\" will render when paged into view.\n */\n\n\nfunction getActiveOffset(dateAdapter, activeDate, minDate, maxDate, yearsPerPage) {\n  const activeYear = dateAdapter.getYear(activeDate);\n  return euclideanModulo(activeYear - getStartingYear(dateAdapter, minDate, maxDate, yearsPerPage), yearsPerPage);\n}\n/**\n * We pick a \"starting\" year such that either the maximum year would be at the end\n * or the minimum year would be at the beginning of a page.\n */\n\n\nfunction getStartingYear(dateAdapter, minDate, maxDate, yearsPerPage) {\n  let startingYear = 0;\n\n  if (maxDate) {\n    const maxYear = dateAdapter.getYear(maxDate);\n    startingYear = maxYear - yearsPerPage + 1;\n  } else if (minDate) {\n    startingYear = dateAdapter.getYear(minDate);\n  }\n\n  return startingYear;\n}\n/** Gets remainder that is non-negative, even if first number is negative */\n\n\nfunction euclideanModulo(a, b) {\n  return (a % b + b) % b;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An internal component used to display a single year in the datepicker.\n * @docs-private\n */\n\n\nlet MatYearView = /*#__PURE__*/(() => {\n  class MatYearView {\n    constructor(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateFormats = _dateFormats;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._rerenderSubscription = Subscription.EMPTY;\n      /** Emits when a new month is selected. */\n\n      this.selectedChange = new EventEmitter();\n      /** Emits the selected month. This doesn't imply a change on the selected date */\n\n      this.monthSelected = new EventEmitter();\n      /** Emits when any date is activated. */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (isDevMode()) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /** The date to display in this year view (everything other than the year is ignored). */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n\n      const validDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\n        this._init();\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n\n      this._setSelectedMonth(value);\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(() => this._init());\n    }\n\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    /** Handles when a new month is selected. */\n\n\n    _monthSelected(event) {\n      const month = event.value;\n\n      const year = this._dateAdapter.getYear(this.activeDate);\n\n      const normalizedDate = this._dateAdapter.createDate(year, month, 1);\n\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\n\n      const day = Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth);\n\n      const activeDate = this._dateAdapter.createDate(year, month, day, this._dateAdapter.getHours(this.activeDate), this._dateAdapter.getMinutes(this.activeDate), this._dateAdapter.getSeconds(this.activeDate), this._dateAdapter.getMilliseconds(this.activeDate));\n\n      this.monthSelected.emit(normalizedDate);\n      this.selectedChange.emit(activeDate);\n    }\n    /** Handles keydown events on the calendar body when calendar is in year view. */\n\n\n    _handleCalendarBodyKeydown(event) {\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n      const oldActiveDate = this._activeDate;\n\n      const isRtl = this._isRtl();\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\n          break;\n\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\n          break;\n\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\n          break;\n\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\n          break;\n\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\n          break;\n\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\n          break;\n\n        case PAGE_UP:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\n          break;\n\n        case PAGE_DOWN:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\n          break;\n\n        case ENTER:\n        case SPACE:\n          this._monthSelected({\n            value: this._dateAdapter.getMonth(this._activeDate),\n            event\n          });\n\n          break;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n\n      this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /** Initializes this year view. */\n\n\n    _init() {\n      this._setSelectedMonth(this.selected);\n\n      this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\n      this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\n\n      let monthNames = this._dateAdapter.getMonthNames('short'); // First row of months only contains 5 elements so we can fit the year label on the same row.\n\n\n      this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(row => row.map(month => this._createCellForMonth(month, monthNames[month])));\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Focuses the active cell after the microtask queue is empty. */\n\n\n    _focusActiveCell() {\n      this._matCalendarBody._focusActiveCell();\n    }\n    /**\n     * Gets the month in this year that the given Date falls on.\n     * Returns null if the given Date is in another year.\n     */\n\n\n    _getMonthInCurrentYear(date) {\n      return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ? this._dateAdapter.getMonth(date) : null;\n    }\n    /** Creates an MatCalendarCell for the given month. */\n\n\n    _createCellForMonth(month, monthName) {\n      const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n\n      const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.monthYearA11yLabel);\n\n      const cellClasses = this.dateClass ? this.dateClass(date, 'year') : undefined;\n      return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month), cellClasses);\n    }\n    /** Whether the given month is enabled. */\n\n\n    _shouldEnableMonth(month) {\n      const activeYear = this._dateAdapter.getYear(this.activeDate);\n\n      if (month === undefined || month === null || this._isYearAndMonthAfterMaxDate(activeYear, month) || this._isYearAndMonthBeforeMinDate(activeYear, month)) {\n        return false;\n      }\n\n      if (!this.dateFilter) {\n        return true;\n      }\n\n      const firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1); // If any date in the month is enabled count the month as enabled.\n\n\n      for (let date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date, 'month')) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Tests whether the combination month/year is after this.maxDate, considering\n     * just the month and year of this.maxDate\n     */\n\n\n    _isYearAndMonthAfterMaxDate(year, month) {\n      if (this.maxDate) {\n        const maxYear = this._dateAdapter.getYear(this.maxDate);\n\n        const maxMonth = this._dateAdapter.getMonth(this.maxDate);\n\n        return year > maxYear || year === maxYear && month > maxMonth;\n      }\n\n      return false;\n    }\n    /**\n     * Tests whether the combination month/year is before this.minDate, considering\n     * just the month and year of this.minDate\n     */\n\n\n    _isYearAndMonthBeforeMinDate(year, month) {\n      if (this.minDate) {\n        const minYear = this._dateAdapter.getYear(this.minDate);\n\n        const minMonth = this._dateAdapter.getMonth(this.minDate);\n\n        return year < minYear || year === minYear && month < minMonth;\n      }\n\n      return false;\n    }\n    /** Determines whether the user has the RTL layout direction. */\n\n\n    _isRtl() {\n      var _a;\n\n      return ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) === 'rtl';\n    }\n    /** Sets the currently-selected month based on a model value. */\n\n\n    _setSelectedMonth(value) {\n      if (value instanceof DateRange) {\n        this._selectedMonth = this._getMonthInCurrentYear(value.start) || this._getMonthInCurrentYear(value.end);\n      } else {\n        this._selectedMonth = this._getMonthInCurrentYear(value);\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  MatYearView.ɵfac = function MatYearView_Factory(t) {\n    return new (t || MatYearView)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(i2.Directionality, 8));\n  };\n  /** @nocollapse */\n\n\n  MatYearView.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatYearView,\n    selectors: [[\"mat-year-view\"]],\n    viewQuery: function MatYearView_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(MatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      monthSelected: \"monthSelected\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"matYearView\"],\n    decls: 5,\n    vars: 9,\n    consts: [[\"role\", \"presentation\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"label\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"labelMinRequiredCells\", \"numCols\", \"cellAspectRatio\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function MatYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"table\", 0);\n        i0.ɵɵelementStart(1, \"thead\", 1);\n        i0.ɵɵelementStart(2, \"tr\");\n        i0.ɵɵelement(3, \"th\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"tbody\", 3);\n        i0.ɵɵlistener(\"selectedValueChange\", function MatYearView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._monthSelected($event);\n        })(\"keydown\", function MatYearView_Template_tbody_keydown_4_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"label\", ctx._yearLabel)(\"rows\", ctx._months)(\"todayValue\", ctx._todayMonth)(\"startValue\", ctx._selectedMonth)(\"endValue\", ctx._selectedMonth)(\"labelMinRequiredCells\", 2)(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._dateAdapter.getMonth(ctx.activeDate));\n      }\n    },\n    directives: [MatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatYearView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Counter used to generate unique IDs. */\n\n\nlet uniqueId = 0;\n/** Default header for MatCalendar */\n\nlet MatCalendarHeader = /*#__PURE__*/(() => {\n  class MatCalendarHeader {\n    constructor(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {\n      this._intl = _intl;\n      this.calendar = calendar;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this.changeDetectorRef = changeDetectorRef;\n      this._buttonDescriptionId = `mat-calendar-button-${uniqueId++}`;\n      this.updateValues();\n      this.calendar.stateChanges.subscribe(() => this.updateValues());\n    }\n\n    get getCssClasses() {\n      const cssClasses = [`type-${this.calendar.type}`];\n\n      if (this.calendar.color) {\n        cssClasses.push(`mat-${this.calendar.color}`);\n      }\n\n      return cssClasses.join(' ');\n    }\n\n    updateValues() {\n      const activeDate = this.calendar.getDate();\n\n      const day = this._dateAdapter.getDayOfWeek(activeDate);\n\n      let hours = this._dateAdapter.getHours(activeDate);\n\n      this._isAM = hours < 12;\n\n      if (this.calendar.twelveHour) {\n        hours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;\n      }\n\n      const minutes = this._dateAdapter.getMinutes(activeDate);\n\n      this._yearButtonText = this._dateAdapter.getYear(activeDate).toString();\n      this._monthButtonText = this._dateAdapter.format(activeDate, this._dateFormats.display.monthLabel);\n      this._monthdayButtonText = this._dateAdapter.format(activeDate, this._dateFormats.display.monthDayLabel);\n      this._dayButtonText = this._dateAdapter.getDayOfWeekNames('short')[day];\n      this._hourButtonText = hours.toString();\n      this._minuteButtonText = ('00' + minutes).slice(-2);\n      this.changeDetectorRef.markForCheck();\n    }\n\n    hasPrevNextBlock() {\n      return !['hour', 'minute'].includes(this.calendar.currentView);\n    }\n\n    isControlActive(views) {\n      return views.includes(this.calendar.currentView);\n    }\n\n    switchToView(view) {\n      this.calendar.currentView = view;\n    }\n\n    toggleAmPm(am) {\n      if (this._isAM !== am) {\n        this.calendar.setDate(this._dateAdapter.addCalendarHours(this.calendar.getDate(), this._isAM ? 12 : -12));\n      }\n    }\n    /** The label for the current calendar view. */\n\n\n    get periodButtonText() {\n      if (this.calendar.currentView == 'month') {\n        return this._dateAdapter.format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase();\n      }\n\n      if (this.calendar.currentView == 'year') {\n        return this._dateAdapter.getYearName(this.calendar.activeDate);\n      } // The offset from the active year to the \"slot\" for the starting year is the\n      // *actual* first rendered year in the multi-year view, and the last year is\n      // just yearsPerPage - 1 away.\n\n\n      const activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\n\n      const minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate, this.calendar.yearsPerPage);\n      const maxYearOfPage = minYearOfPage + this.calendar.yearsPerPage - 1;\n\n      const minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));\n\n      const maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));\n\n      return this._intl.formatYearRange(minYearName, maxYearName);\n    }\n\n    get monthdayButtonLabel() {\n      return this.calendar.currentView == 'month' ? this._intl.switchToYearViewLabel : this._intl.switchToMonthViewLabel;\n    }\n\n    get periodButtonLabel() {\n      return this.calendar.currentView == 'month' ? this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;\n    }\n    /** The label for the previous button. */\n\n\n    get prevButtonLabel() {\n      return {\n        'month': this._intl.prevMonthLabel,\n        'year': this._intl.prevYearLabel,\n        'multi-year': this._intl.prevMultiYearLabel\n      }[this.calendar.currentView];\n    }\n    /** The label for the next button. */\n\n\n    get nextButtonLabel() {\n      return {\n        'month': this._intl.nextMonthLabel,\n        'year': this._intl.nextYearLabel,\n        'multi-year': this._intl.nextMultiYearLabel\n      }[this.calendar.currentView];\n    }\n\n    monthdayClicked() {\n      this.calendar.currentView = this.calendar.currentView == 'month' ? 'year' : 'month';\n    }\n\n    currentPeriodDisabled() {\n      return ['year', 'month'].includes(this.calendar.type);\n    }\n    /** Handles user clicks on the period label. */\n\n\n    currentPeriodClicked() {\n      this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\n    }\n    /** Handles user clicks on the previous button. */\n\n\n    previousClicked() {\n      const date = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -this.calendar.yearsPerPage);\n      this.calendar.setDate(date);\n    }\n    /** Handles user clicks on the next button. */\n\n\n    nextClicked() {\n      const date = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : this.calendar.yearsPerPage);\n      this.calendar.setDate(date);\n    }\n    /** Whether the previous period button is enabled. */\n\n\n    previousEnabled() {\n      if (!this.calendar.minDate) {\n        return true;\n      }\n\n      return !this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate);\n    }\n    /** Whether the next period button is enabled. */\n\n\n    nextEnabled() {\n      return !this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);\n    }\n    /** Whether the two dates represent the same view in the current view mode (month or year). */\n\n\n    _isSameView(date1, date2) {\n      if (this.calendar.currentView == 'month') {\n        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) && this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);\n      }\n\n      if (this.calendar.currentView == 'year') {\n        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\n      } // Otherwise we are in 'multi-year' view.\n\n\n      return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate, this.calendar.yearsPerPage);\n    }\n\n  }\n\n  /** @nocollapse */\n  MatCalendarHeader.ɵfac = function MatCalendarHeader_Factory(t) {\n    return new (t || MatCalendarHeader)(i0.ɵɵdirectiveInject(MatDatepickerIntl), i0.ɵɵdirectiveInject(forwardRef(() => MatCalendar)), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n\n\n  MatCalendarHeader.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatCalendarHeader,\n    selectors: [[\"mat-custom-header\"]],\n    hostVars: 2,\n    hostBindings: function MatCalendarHeader_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.getCssClasses);\n      }\n    },\n    exportAs: [\"matCalendarHeader\"],\n    decls: 7,\n    vars: 5,\n    consts: [[1, \"mat-custom-header\"], [1, \"mat-custom-controls\"], [\"class\", \"mat-custom-date\", 4, \"ngIf\"], [\"class\", \"mat-custom-time\", 4, \"ngIf\"], [\"class\", \"mat-custom-prev-next\", 4, \"ngIf\"], [1, \"mat-custom-date\"], [\"mat-button\", \"\", \"type\", \"button\", 1, \"mat-custom-date-year\", \"mat-custom-control\", 3, \"click\"], [\"mat-button\", \"\", \"type\", \"button\", 1, \"mat-custom-date-month\", \"mat-custom-control\", 3, \"click\"], [\"mat-button\", \"\", \"type\", \"button\", 1, \"mat-custom-date-monthday\", \"mat-custom-control\", 3, \"click\"], [1, \"mat-custom-date-year-dayname\"], [1, \"mat-custom-date-year-monthday\"], [1, \"mat-custom-time\"], [1, \"mat-custom-time-hour\"], [\"mat-button\", \"\", \"type\", \"button\", 1, \"mat-custom-time-hour\", \"mat-custom-control\", 3, \"click\"], [1, \"mat-custom-separator\"], [\"mat-button\", \"\", \"type\", \"button\", 1, \"mat-custom-time-minute\", \"mat-custom-control\", 3, \"click\"], [\"class\", \"mat-custom-time-ampm\", 4, \"ngIf\"], [1, \"mat-custom-time-ampm\"], [\"mat-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-control\", 3, \"click\"], [1, \"mat-custom-prev-next\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-previous-button\", 3, \"disabled\", \"click\"], [\"mat-button\", \"\", \"type\", \"button\", \"disableRipple\", \"true\", 1, \"mat-custom-period\", \"mat-custom-control\", 3, \"disabled\", \"click\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-next-button\", 3, \"disabled\", \"click\"]],\n    template: function MatCalendarHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵtemplate(2, MatCalendarHeader_div_2_Template, 4, 7, \"div\", 2);\n        i0.ɵɵtemplate(3, MatCalendarHeader_div_3_Template, 7, 14, \"div\", 2);\n        i0.ɵɵtemplate(4, MatCalendarHeader_div_4_Template, 9, 15, \"div\", 2);\n        i0.ɵɵtemplate(5, MatCalendarHeader_div_5_Template, 11, 15, \"div\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, MatCalendarHeader_div_6_Template, 6, 7, \"div\", 4);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.calendar.type === \"year\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.calendar.type === \"month\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.calendar.hasOutput(\"date\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.calendar.hasOutput(\"time\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasPrevNextBlock());\n      }\n    },\n    directives: [i4.NgIf, i3.MatButton],\n    styles: [\"mat-custom-header *{box-sizing:border-box}mat-custom-header .mat-custom-control,mat-custom-header .mat-custom-separator{opacity:.75}mat-custom-header .mat-custom-control-active{opacity:1}mat-custom-header .mat-custom-controls{display:flex;flex-direction:row;padding:5% 4%}mat-custom-header .mat-custom-controls .mat-button{font-size:inherit;font-weight:inherit;line-height:inherit;padding:0;min-width:auto}mat-custom-header .mat-custom-controls .mat-custom-date{display:flex;flex-direction:column;flex:1 1 auto;place-content:flex-start;align-items:flex-start}mat-custom-header .mat-custom-controls .mat-custom-date-year{font-size:16px;line-height:20px}mat-custom-header .mat-custom-controls .mat-custom-date-year-dayname{display:none}mat-custom-header .mat-custom-controls .mat-custom-date-monthday{font-size:42px;line-height:36px}mat-custom-header .mat-custom-controls .mat-custom-time{display:flex;flex-direction:row;flex:1 1 auto;place-content:flex-end;align-items:flex-end}mat-custom-header .mat-custom-controls .mat-custom-time-hour{display:flex;flex-direction:row;place-content:center flex-end;align-items:center;font-size:42px;line-height:36px}mat-custom-header .mat-custom-controls .mat-custom-time-ampm{display:flex;flex-direction:column;font-size:16px;line-height:18px;min-width:30px}mat-custom-header .mat-custom-controls .mat-custom-time-ampm .mat-custom-control-active{font-weight:500;opacity:1}mat-custom-header .mat-custom-prev-next{display:flex;flex-direction:row;place-content:stretch space-between;align-items:stretch;padding:1% 0}mat-custom-header .mat-custom-prev-next .mat-button .mat-button-focus-overlay{display:none}mat-custom-header.type-year .mat-custom-controls .mat-custom-date{place-content:center;align-items:center}mat-custom-header.type-year .mat-custom-controls .mat-custom-date-year{font-size:42px;line-height:36px}mat-custom-header.type-month .mat-custom-controls .mat-custom-date{flex-direction:row;place-content:center;align-items:center}mat-custom-header.type-month .mat-custom-controls .mat-custom-date-month,mat-custom-header.type-month .mat-custom-controls .mat-custom-date-year{font-size:42px;line-height:36px}mat-custom-header.type-month .mat-custom-controls .mat-custom-date-month:not(:last-child),mat-custom-header.type-month .mat-custom-controls .mat-custom-date-year:not(:last-child){margin-right:.2em}mat-custom-header.type-date .mat-custom-controls .mat-custom-date{flex-direction:row-reverse;place-content:center;align-items:center}mat-custom-header.type-date .mat-custom-controls .mat-custom-date-monthday:after{content:\\\", \\\";display:inline-block}mat-custom-header.type-date .mat-custom-controls .mat-custom-date-year{font-size:42px;line-height:36px;margin-left:.2em}mat-custom-header.type-datetime .mat-custom-controls .mat-custom-date-year{font-weight:500}mat-custom-header.type-time .mat-custom-controls .mat-custom-time{place-content:center;align-items:center}mat-custom-header.type-time .mat-custom-controls .mat-custom-time-hour{font-size:56px;line-height:56px}mat-custom-header.type-time .mat-custom-controls .mat-custom-time-hour,mat-custom-header.type-time .mat-custom-controls .mat-custom-time-minute{min-width:62px}mat-custom-header.type-time .mat-custom-controls .mat-custom-time-ampm{font-size:22px;line-height:24px;margin-top:4px;min-width:45px}\\n\"],\n    encapsulation: 2,\n    data: {\n      animation: [matDatepickerAnimations.controlActive]\n    },\n    changeDetection: 0\n  });\n  return MatCalendarHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A calendar that is used as part of the datepicker.\n * @docs-private\n */\n\n\nlet MatCalendar = /*#__PURE__*/(() => {\n  class MatCalendar {\n    constructor(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this._changeDetectorRef = _changeDetectorRef;\n      /**\n       * Used for scheduling that focus should be moved to the active cell on the next tick.\n       * We need to schedule it, rather than do it immediately, because we have to wait\n       * for Angular to re-evaluate the view children.\n       */\n\n      this._moveFocusOnNextTick = false;\n      /** The type of value handled by the calendar. */\n\n      this.type = 'date';\n      /** Whether the calendar should be started in. */\n\n      this.startView = 'month';\n      /** multi-year inputs */\n\n      this.yearsPerPage = 24;\n      this.yearsPerRow = 4;\n      /** Clock interval */\n\n      this.clockStep = 1;\n      /** Clock hour format */\n\n      this.twelveHour = false;\n      /** Emits when the currently selected date changes. */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emits the year chosen in multiyear view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\n       * Emits the month chosen in year view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\n       * Emits when the date changes.\n       */\n\n      this.dateChanged = new EventEmitter();\n      /**\n       * Emits when the current view changes.\n       */\n\n      this.viewChanged = new EventEmitter(true);\n      /** Emits when any date is selected. */\n\n      this._userSelection = new EventEmitter();\n      /**\n       * Emits whenever there is a state change that the header may need to respond to.\n       */\n\n      this.stateChanges = new Subject();\n\n      if (isDevMode()) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n\n      this._intlChanges = _intl.changes.subscribe(() => {\n        _changeDetectorRef.markForCheck();\n\n        this.stateChanges.next();\n      });\n    }\n    /** A date representing the period (month or year) to start the calendar in. */\n\n\n    get startAt() {\n      return this._startAt;\n    }\n\n    set startAt(value) {\n      this._startAt = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\n     * The current active date. This determines which time period is shown and which date is\n     * highlighted when using keyboard navigation.\n     */\n\n\n    get activeDate() {\n      return this._clampedActiveDate;\n    }\n\n    set activeDate(value) {\n      this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\n      this.stateChanges.next();\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Whether the calendar is in month view. */\n\n\n    get currentView() {\n      return this._currentView;\n    }\n\n    set currentView(value) {\n      const viewChangedResult = this._currentView !== value ? value : null;\n      this._currentView = value;\n      this._moveFocusOnNextTick = true;\n\n      this._changeDetectorRef.markForCheck();\n\n      if (viewChangedResult) {\n        this.viewChanged.emit(viewChangedResult);\n      }\n    }\n\n    ngAfterContentInit() {\n      this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);\n      this.activeDate = this.startAt || this._dateAdapter.today(); // Assign to the private property since we don't want to move focus on init.\n\n      this._currentView = this.type === 'year' ? 'multi-year' : this.type === 'month' ? 'year' : this.type === 'time' && !['hour', 'minute'].includes(this.startView) ? 'hour' : this.startView;\n    }\n\n    ngAfterViewChecked() {\n      if (this._moveFocusOnNextTick) {\n        this._moveFocusOnNextTick = false;\n        this.focusActiveCell();\n      }\n    }\n\n    ngOnDestroy() {\n      this._intlChanges.unsubscribe();\n\n      this.stateChanges.complete();\n    }\n\n    ngOnChanges(changes) {\n      const change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];\n\n      if (change && !change.firstChange) {\n        const view = this._getCurrentViewComponent();\n\n        if (view) {\n          // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are\n          // passed down to the view via data bindings which won't be up-to-date when we call `_init`.\n          this._changeDetectorRef.detectChanges();\n\n          view._init();\n        }\n      }\n\n      this.stateChanges.next();\n    }\n\n    focusActiveCell() {\n      this._getCurrentViewComponent()._focusActiveCell(false);\n    }\n\n    hasOutput(type) {\n      return this.type.indexOf(type) !== -1;\n    }\n\n    getDate() {\n      return !this.selected || this.selected instanceof DateRange ? this.activeDate : this.selected;\n    }\n\n    getUnit() {\n      switch (this.type) {\n        case 'date':\n          return 'day';\n\n        case 'datetime':\n        case 'time':\n          return 'minute';\n\n        default:\n          return this.type;\n      }\n    }\n\n    setDate(date) {\n      if (!(this.selected instanceof DateRange)) {\n        this.selected = date;\n      }\n\n      this.activeDate = date;\n      this.dateChanged.emit(date);\n    }\n    /** Updates today's date after an update of the active date */\n\n\n    updateTodaysDate() {\n      const currentView = this.currentView;\n      let view;\n\n      if (currentView === 'month') {\n        view = this.monthView;\n      } else if (currentView === 'year') {\n        view = this.yearView;\n      } else if (currentView === 'multi-year') {\n        view = this.multiYearView;\n      } else {\n        view = this.clockView;\n      }\n\n      view._init();\n    }\n    /** Handles date selection. */\n\n\n    _dateSelected(event) {\n      const date = event.value;\n\n      if (this.selected instanceof DateRange || date && !this._dateAdapter.sameDate(date, this.selected, this.getUnit())) {\n        this.selectedChange.emit(date);\n      }\n\n      this._userSelection.emit(event);\n    }\n\n    _dateEmit(value) {\n      this.setDate(value);\n\n      this._userSelection.emit({\n        value,\n        event: null\n      });\n    }\n    /** Handles date selection in the clock view. */\n\n\n    _hourSelectedInClockView(date) {\n      this.setDate(date);\n      this.selectedChange.emit(date);\n    }\n\n    _timeSelectedInClockView(event) {\n      this.setDate(event.value);\n      this.selectedChange.emit(event.value);\n\n      this._userSelection.emit(event);\n    }\n    /** Handles user day selection. */\n\n\n    _daySelected(event) {\n      if (!this.hasOutput('time') || this.selected instanceof DateRange) {\n        this.setDate(event.value);\n\n        this._dateSelected(event);\n      } else {\n        this.selectedChange.emit(event.value);\n\n        this._goToDateInView(event.value, 'hour');\n      }\n    }\n    /** Handles year selection in the multiyear view. */\n\n\n    _yearSelectedInMultiYearView(normalizedYear) {\n      this.yearSelected.emit(normalizedYear);\n    }\n    /** Handles month selection in the year view. */\n\n\n    _monthSelectedInYearView(normalizedMonth) {\n      this.monthSelected.emit(normalizedMonth);\n    }\n    /** Handles year/month selection in the multi-year/year views. */\n\n\n    _goToDateInView(date, view) {\n      this.setDate(date);\n      this.currentView = view;\n    }\n    /** Returns the component instance that corresponds to the current calendar view. */\n\n\n    _getCurrentViewComponent() {\n      return this.clockView || this.monthView || this.yearView || this.multiYearView;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatCalendar.ɵfac = function MatCalendar_Factory(t) {\n    return new (t || MatCalendar)(i0.ɵɵdirectiveInject(MatDatepickerIntl), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n\n\n  MatCalendar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatCalendar,\n    selectors: [[\"mat-calendar\"]],\n    viewQuery: function MatCalendar_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(MatClockView, 5);\n        i0.ɵɵviewQuery(MatMonthView, 5);\n        i0.ɵɵviewQuery(MatYearView, 5);\n        i0.ɵɵviewQuery(MatMultiYearView, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clockView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.multiYearView = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-calendar\"],\n    hostVars: 2,\n    hostBindings: function MatCalendar_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.type);\n      }\n    },\n    inputs: {\n      headerComponent: \"headerComponent\",\n      startAt: \"startAt\",\n      color: \"color\",\n      type: \"type\",\n      startView: \"startView\",\n      yearsPerPage: \"yearsPerPage\",\n      yearsPerRow: \"yearsPerRow\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\",\n      clockStep: \"clockStep\",\n      twelveHour: \"twelveHour\",\n      comparisonStart: \"comparisonStart\",\n      comparisonEnd: \"comparisonEnd\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      dateChanged: \"dateChanged\",\n      viewChanged: \"viewChanged\",\n      _userSelection: \"_userSelection\"\n    },\n    exportAs: [\"matCalendar\"],\n    features: [i0.ɵɵProvidersFeature([MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER]), i0.ɵɵNgOnChangesFeature],\n    decls: 6,\n    vars: 5,\n    consts: [[3, \"cdkPortalOutlet\"], [\"cdkMonitorSubtreeFocus\", \"\", \"tabindex\", \"-1\", 1, \"mat-calendar-content\", 3, \"ngSwitch\"], [3, \"activeDate\", \"selected\", \"currentView\", \"dateFilter\", \"dateClass\", \"clockStep\", \"twelveHour\", \"activeDateChange\", \"currentViewChange\", \"selectedChange\", \"hourSelected\", \"_userSelection\", 4, \"ngSwitchDefault\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"comparisonStart\", \"comparisonEnd\", \"activeDateChange\", \"_userSelection\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"activeDateChange\", \"monthSelected\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"yearsPerPage\", \"yearsPerRow\", \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"activeDateChange\", \"yearSelected\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"currentView\", \"dateFilter\", \"dateClass\", \"clockStep\", \"twelveHour\", \"activeDateChange\", \"currentViewChange\", \"selectedChange\", \"hourSelected\", \"_userSelection\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"comparisonStart\", \"comparisonEnd\", \"activeDateChange\", \"_userSelection\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"activeDateChange\", \"monthSelected\", \"selectedChange\"], [3, \"yearsPerPage\", \"yearsPerRow\", \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"activeDateChange\", \"yearSelected\", \"selectedChange\"]],\n    template: function MatCalendar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, MatCalendar_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵtemplate(2, MatCalendar_mat_clock_view_2_Template, 1, 8, \"mat-clock-view\", 2);\n        i0.ɵɵtemplate(3, MatCalendar_mat_month_view_3_Template, 1, 8, \"mat-month-view\", 3);\n        i0.ɵɵtemplate(4, MatCalendar_mat_year_view_4_Template, 1, 6, \"mat-year-view\", 4);\n        i0.ɵɵtemplate(5, MatCalendar_mat_multi_year_view_5_Template, 1, 8, \"mat-multi-year-view\", 5);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"cdkPortalOutlet\", ctx._calendarHeaderPortal);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitch\", ctx.currentView);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"month\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"year\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"multi-year\");\n      }\n    },\n    directives: [i9.CdkPortalOutlet, i10.CdkMonitorFocus, i4.NgSwitch, i4.NgSwitchDefault, i4.NgSwitchCase, MatClockView, MatMonthView, MatYearView, MatMultiYearView],\n    styles: [\".mat-calendar{display:flex;flex-direction:column}.mat-calendar-header{padding:8px 8px 0}.mat-calendar-content{padding:0 8px 8px;outline:none}.mat-calendar-controls{display:flex;margin:5% calc(4.7142857143% - 16px)}.mat-calendar-controls .mat-icon-button:hover .mat-button-focus-overlay{opacity:.04}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-previous-button,.mat-calendar-next-button{position:relative}.mat-calendar-previous-button:after,.mat-calendar-next-button:after{top:0;left:0;right:0;bottom:0;position:absolute;content:\\\"\\\";margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-previous-button,[dir=rtl] .mat-calendar-next-button{transform:rotate(180deg)}.mat-calendar-previous-button:after{border-left-width:2px;transform:translate(2px) rotate(-45deg)}.mat-calendar-next-button:after{border-right-width:2px;transform:translate(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider:after{content:\\\"\\\";position:absolute;top:0;left:-8px;right:-8px;height:1px}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCalendar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Used to generate a unique ID for each datepicker instance. */\n\n\nlet datepickerUid = 0;\n/** Injection token that determines the scroll handling while the calendar is open. */\n\nconst MAT_DATEPICKER_SCROLL_STRATEGY = new InjectionToken('mat-datepicker-scroll-strategy');\n/** @docs-private */\n\nfunction MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\n\n\nconst MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_DATEPICKER_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY\n}; // Boilerplate for applying mixins to MatDatepickerContent.\n\n/** @docs-private */\n\nclass MatDatepickerContentBase {\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n\n}\n\nconst _MatDatepickerContentMixinBase = mixinColor(MatDatepickerContentBase);\n/**\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\n * MatCalendar directly as the content so we can control the initial focus. This also gives us a\n * place to put additional features of the popup that are not part of the calendar itself in the\n * future. (e.g. confirmation buttons).\n * @docs-private\n */\n\n\nlet MatDatepickerContent = /*#__PURE__*/(() => {\n  class MatDatepickerContent extends _MatDatepickerContentMixinBase {\n    constructor(elementRef, _changeDetectorRef, _globalModel, _dateAdapter, _rangeSelectionStrategy,\n    /**\n     * @deprecated `intl` argument to become required.\n     * @breaking-change 12.0.0\n     */\n    intl) {\n      super(elementRef);\n      this._changeDetectorRef = _changeDetectorRef;\n      this._globalModel = _globalModel;\n      this._dateAdapter = _dateAdapter;\n      this._rangeSelectionStrategy = _rangeSelectionStrategy;\n      this._subscriptions = new Subscription();\n      /** Current state of the animation. */\n\n      this._animationState = 'enter';\n      /** Emits when an animation has finished. */\n\n      this._animationDone = new Subject();\n      /** Portal with projected action buttons. */\n\n      this._actionsPortal = null; // @breaking-change 12.0.0 Remove fallback for `intl`.\n\n      this._closeButtonText = (intl === null || intl === void 0 ? void 0 : intl.closeCalendarLabel) || 'Close calendar';\n    }\n\n    ngOnInit() {\n      // If we have actions, clone the model so that we have the ability to cancel the selection,\n      // otherwise update the global model directly. Note that we want to assign this as soon as\n      // possible, but `_actionsPortal` isn't available in the constructor so we do it in `ngOnInit`.\n      this._model = this._actionsPortal ? this._globalModel.clone() : this._globalModel;\n    }\n\n    ngAfterViewInit() {\n      this._subscriptions.add(this.datepicker.stateChanges.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n      }));\n\n      this._calendar.focusActiveCell();\n    }\n\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n\n      this._animationDone.complete();\n    }\n\n    _queueUserSelection(date) {\n      this._model.queue(date);\n    }\n\n    _handleUserSelection(event) {\n      const selection = this._model.selection;\n      const value = event.value;\n      const isRange = selection instanceof DateRange; // If we're selecting a range and we have a selection strategy, always pass the value through\n      // there. Otherwise don't assign null values to the model, unless we're selecting a range.\n      // A null value when picking a range means that the user cancelled the selection (e.g. by\n      // pressing escape), whereas when selecting a single value it means that the value didn't\n      // change. This isn't very intuitive, but it's here for backwards-compatibility.\n\n      if (isRange && this._rangeSelectionStrategy) {\n        const newSelection = this._rangeSelectionStrategy.selectionFinished(value, selection, event.event);\n\n        this._model.updateSelection(newSelection, this);\n      } else if (value && (isRange || !this._dateAdapter.sameDate(value, selection, this._calendar.getUnit()))) {\n        this._model.add(value);\n      } // Delegate closing the popup to the actions.\n\n\n      if ((!this._model || this._model.isComplete()) && !this._actionsPortal) {\n        this.datepicker.close();\n      }\n    }\n\n    _startExitAnimation() {\n      this._animationState = 'void';\n\n      this._changeDetectorRef.markForCheck();\n    }\n\n    _getSelected() {\n      return this._model.selection;\n    }\n    /** Applies the current pending selection to the global model. */\n\n\n    _applyPendingSelection() {\n      this._model.processQueue();\n\n      if (this._model !== this._globalModel) {\n        this._globalModel.updateSelection(this._model.selection, this);\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerContent.ɵfac = function MatDatepickerContent_Factory(t) {\n    return new (t || MatDatepickerContent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MatDateSelectionModel), i0.ɵɵdirectiveInject(i1.DateAdapter), i0.ɵɵdirectiveInject(MAT_DATE_RANGE_SELECTION_STRATEGY, 8), i0.ɵɵdirectiveInject(MatDatepickerIntl));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerContent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatDatepickerContent,\n    selectors: [[\"mat-datepicker-content\"]],\n    viewQuery: function MatDatepickerContent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(MatCalendar, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._calendar = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-datepicker-content\"],\n    hostVars: 3,\n    hostBindings: function MatDatepickerContent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@transformPanel.done\", function MatDatepickerContent_animation_transformPanel_done_HostBindingHandler() {\n          return ctx._animationDone.next();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@transformPanel\", ctx._animationState);\n        i0.ɵɵclassProp(\"mat-datepicker-content-touch\", ctx.datepicker.touchUi);\n      }\n    },\n    inputs: {\n      color: \"color\"\n    },\n    exportAs: [\"matDatepickerContent\"],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 5,\n    vars: 26,\n    consts: [[\"cdkTrapFocus\", \"\", 1, \"mat-datepicker-content-container\"], [3, \"id\", \"ngClass\", \"color\", \"type\", \"startAt\", \"startView\", \"yearsPerPage\", \"yearsPerRow\", \"clockStep\", \"twelveHour\", \"minDate\", \"maxDate\", \"dateFilter\", \"headerComponent\", \"selected\", \"dateClass\", \"comparisonStart\", \"comparisonEnd\", \"yearSelected\", \"monthSelected\", \"viewChanged\", \"dateChanged\", \"_userSelection\"], [3, \"cdkPortalOutlet\"], [\"type\", \"button\", \"mat-raised-button\", \"\", 1, \"mat-datepicker-close-button\", 3, \"color\", \"focus\", \"blur\", \"click\"]],\n    template: function MatDatepickerContent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"mat-calendar\", 1);\n        i0.ɵɵlistener(\"yearSelected\", function MatDatepickerContent_Template_mat_calendar_yearSelected_1_listener($event) {\n          return ctx.datepicker._selectYear($event);\n        })(\"monthSelected\", function MatDatepickerContent_Template_mat_calendar_monthSelected_1_listener($event) {\n          return ctx.datepicker._selectMonth($event);\n        })(\"viewChanged\", function MatDatepickerContent_Template_mat_calendar_viewChanged_1_listener($event) {\n          return ctx.datepicker._viewChanged($event);\n        })(\"dateChanged\", function MatDatepickerContent_Template_mat_calendar_dateChanged_1_listener($event) {\n          return ctx._queueUserSelection($event);\n        })(\"_userSelection\", function MatDatepickerContent_Template_mat_calendar__userSelection_1_listener($event) {\n          return ctx._handleUserSelection($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, MatDatepickerContent_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n        i0.ɵɵelementStart(3, \"button\", 3);\n        i0.ɵɵlistener(\"focus\", function MatDatepickerContent_Template_button_focus_3_listener() {\n          return ctx._closeButtonFocused = true;\n        })(\"blur\", function MatDatepickerContent_Template_button_blur_3_listener() {\n          return ctx._closeButtonFocused = false;\n        })(\"click\", function MatDatepickerContent_Template_button_click_3_listener() {\n          return ctx.datepicker.close();\n        });\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"mat-datepicker-content-container-with-actions\", ctx._actionsPortal);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.datepicker.id)(\"ngClass\", ctx.datepicker.panelClass)(\"color\", ctx.datepicker.color)(\"type\", ctx.datepicker.type)(\"startAt\", ctx.datepicker.startAt)(\"startView\", ctx.datepicker.startView)(\"yearsPerPage\", ctx.datepicker.yearsPerPage)(\"yearsPerRow\", ctx.datepicker.yearsPerRow)(\"clockStep\", ctx.datepicker.clockStep)(\"twelveHour\", ctx.datepicker.twelveHour)(\"minDate\", ctx.datepicker._getMinDate())(\"maxDate\", ctx.datepicker._getMaxDate())(\"dateFilter\", ctx.datepicker._getDateFilter())(\"headerComponent\", ctx.datepicker.calendarHeaderComponent)(\"selected\", ctx._getSelected())(\"dateClass\", ctx.datepicker.dateClass)(\"comparisonStart\", ctx.comparisonStart)(\"comparisonEnd\", ctx.comparisonEnd)(\"@fadeInCalendar\", \"enter\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"cdkPortalOutlet\", ctx._actionsPortal);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"cdk-visually-hidden\", !ctx._closeButtonFocused);\n        i0.ɵɵproperty(\"color\", ctx.color || \"primary\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx._closeButtonText);\n      }\n    },\n    directives: [i10.CdkTrapFocus, MatCalendar, i4.NgClass, i9.CdkPortalOutlet, i3.MatButton],\n    styles: [\".mat-datepicker-content{display:flex;flex-direction:column;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:400px}.mat-datepicker-content .mat-calendar.datetime{height:420px}.mat-datepicker-content .mat-calendar.month{height:auto}.mat-datepicker-content .mat-datepicker-close-button{position:absolute;top:100%;left:0;margin-top:8px}.ng-animating .mat-datepicker-content .mat-datepicker-close-button{display:none}.mat-datepicker-content-container{display:flex;flex-direction:column;justify-content:stretch}.mat-datepicker-content-container .mat-calendar{flex:20 20 auto}.mat-datepicker-content-container .mat-calendar .mat-calendar-content{flex:1}.mat-datepicker-content-container .mat-calendar-actions{flex:1 0 auto}.mat-datepicker-content-touch{max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-datepicker-content-container{min-height:312px;max-height:788px;min-width:250px;max-width:750px}.mat-datepicker-content-touch .mat-calendar{width:100%;height:auto}@media all and (orientation: landscape){.mat-datepicker-content-touch .mat-datepicker-content-container{width:64vh;height:80vh}}@media all and (orientation: portrait){.mat-datepicker-content-touch .mat-datepicker-content-container{width:80vw;height:100vw}.mat-datepicker-content-touch .mat-datepicker-content-container-with-actions{height:115vw}}\\n\"],\n    encapsulation: 2,\n    data: {\n      animation: [matDatepickerAnimations.transformPanel, matDatepickerAnimations.fadeInCalendar]\n    },\n    changeDetection: 0\n  });\n  return MatDatepickerContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Base class for a datepicker. */\n\n\nlet MatDatepickerBase = /*#__PURE__*/(() => {\n  class MatDatepickerBase {\n    constructor(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document, _model) {\n      this._dialog = _dialog;\n      this._overlay = _overlay;\n      this._ngZone = _ngZone;\n      this._viewContainerRef = _viewContainerRef;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._document = _document;\n      this._model = _model;\n      this._inputStateChanges = Subscription.EMPTY;\n      /** The type of value handled by the calendar. */\n\n      this.type = 'date';\n      /** The view that the calendar should start in. */\n\n      this.startView = 'month';\n      /** multi-year inputs */\n\n      this.yearsPerPage = 24;\n      this.yearsPerRow = 4;\n      /** Clock interval */\n\n      this.clockStep = 1;\n      /** Clock hour format */\n\n      this.twelveHour = true;\n      this._touchUi = false;\n      /** Preferred position of the datepicker in the X axis. */\n\n      this.xPosition = 'start';\n      /** Preferred position of the datepicker in the Y axis. */\n\n      this.yPosition = 'below';\n      this._restoreFocus = true;\n      /**\n       * Emits selected year in multiyear view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\n       * Emits selected month in year view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\n       * Emits when the current view changes.\n       */\n\n      this.viewChanged = new EventEmitter(true);\n      /** Emits when the datepicker has been opened. */\n\n      this.openedStream = new EventEmitter();\n      /** Emits when the datepicker has been closed. */\n\n      this.closedStream = new EventEmitter();\n      this._opened = false;\n      /** The id for the datepicker calendar. */\n\n      this.id = `mat-datepicker-${datepickerUid++}`;\n      /** The element that was focused before the datepicker was opened. */\n\n      this._focusedElementBeforeOpen = null;\n      /** Unique class that will be added to the backdrop so that the test harnesses can look it up. */\n\n      this._backdropHarnessClass = `${this.id}-backdrop`;\n      /** Emits when the datepicker's state changes. */\n\n      this.stateChanges = new Subject();\n\n      if (!this._dateAdapter && isDevMode()) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      this._scrollStrategy = scrollStrategy;\n    }\n    /** The date to open the calendar to initially. */\n\n\n    get startAt() {\n      // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n      // selected value is.\n      return this._startAt || (this.datepickerInput ? this.datepickerInput.getStartValue() : null);\n    }\n\n    set startAt(value) {\n      this._startAt = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /** Color palette to use on the datepicker's calendar. */\n\n\n    get color() {\n      return this._color || (this.datepickerInput ? this.datepickerInput.getThemePalette() : undefined);\n    }\n\n    set color(value) {\n      this._color = value;\n    }\n    /**\n     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\n     * than a popup and elements have more padding to allow for bigger touch targets.\n     */\n\n\n    get touchUi() {\n      return this._touchUi;\n    }\n\n    set touchUi(value) {\n      this._touchUi = coerceBooleanProperty(value);\n    }\n    /** Whether the datepicker pop-up should be disabled. */\n\n\n    get disabled() {\n      return this._disabled === undefined && this.datepickerInput ? this.datepickerInput.disabled : !!this._disabled;\n    }\n\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n        this.stateChanges.next(undefined);\n      }\n    }\n    /**\n     * Whether to restore focus to the previously-focused element when the calendar is closed.\n     * Note that automatic focus restoration is an accessibility feature and it is recommended that\n     * you provide your own equivalent, if you decide to turn it off.\n     */\n\n\n    get restoreFocus() {\n      return this._restoreFocus;\n    }\n\n    set restoreFocus(value) {\n      this._restoreFocus = coerceBooleanProperty(value);\n    }\n    /**\n     * Classes to be passed to the date picker panel.\n     * Supports string and string array values, similar to `ngClass`.\n     */\n\n\n    get panelClass() {\n      return this._panelClass;\n    }\n\n    set panelClass(value) {\n      this._panelClass = coerceStringArray(value);\n    }\n    /** Whether the calendar is open. */\n\n\n    get opened() {\n      return this._opened;\n    }\n\n    set opened(value) {\n      coerceBooleanProperty(value) ? this.open() : this.close();\n    }\n    /** The minimum selectable date. */\n\n\n    _getMinDate() {\n      var _a;\n\n      return (_a = this.datepickerInput) === null || _a === void 0 ? void 0 : _a.min;\n    }\n    /** The maximum selectable date. */\n\n\n    _getMaxDate() {\n      var _a;\n\n      return (_a = this.datepickerInput) === null || _a === void 0 ? void 0 : _a.max;\n    }\n\n    _getDateFilter() {\n      var _a;\n\n      return (_a = this.datepickerInput) === null || _a === void 0 ? void 0 : _a.dateFilter;\n    }\n\n    ngOnChanges(changes) {\n      const positionChange = changes['xPosition'] || changes['yPosition'];\n\n      if (positionChange && !positionChange.firstChange && this._popupRef) {\n        this._setConnectedPositions(this._popupRef.getConfig().positionStrategy);\n\n        if (this.opened) {\n          this._popupRef.updatePosition();\n        }\n      }\n\n      if (this.datepickerInput.type !== this.type) {\n        this.datepickerInput.type = this.type;\n      }\n\n      this.stateChanges.next(undefined);\n    }\n\n    ngOnDestroy() {\n      this._destroyPopup();\n\n      this.close();\n\n      this._inputStateChanges.unsubscribe();\n\n      this.stateChanges.complete();\n    }\n    /** Selects the given date */\n\n\n    select(date) {\n      this._model.add(date);\n    }\n    /** Emits the selected year in multiyear view */\n\n\n    _selectYear(normalizedYear) {\n      this.yearSelected.emit(normalizedYear);\n    }\n    /** Emits selected month in year view */\n\n\n    _selectMonth(normalizedMonth) {\n      this.monthSelected.emit(normalizedMonth);\n    }\n    /** Emits changed view */\n\n\n    _viewChanged(view) {\n      this.viewChanged.emit(view);\n    }\n\n    _queueDate(date) {\n      this._model.queue(date);\n    }\n    /**\n     * Register an input with this datepicker.\n     * @param input The datepicker input to register with this datepicker.\n     * @returns Selection model that the input should hook itself up to.\n     */\n\n\n    registerInput(input) {\n      if (this.datepickerInput && isDevMode()) {\n        throw Error('A MatDatepicker can only be associated with a single input.');\n      }\n\n      this._inputStateChanges.unsubscribe();\n\n      this.datepickerInput = input;\n      this.datepickerInput.type = this.type;\n      this._inputStateChanges = input.stateChanges.subscribe(() => this.stateChanges.next(undefined));\n      return this._model;\n    }\n    /**\n     * Registers a portal containing action buttons with the datepicker.\n     * @param portal Portal to be registered.\n     */\n\n\n    registerActions(portal) {\n      if (this._actionsPortal && isDevMode()) {\n        throw Error('A MatDatepicker can only be associated with a single actions row.');\n      }\n\n      this._actionsPortal = portal;\n    }\n    /**\n     * Removes a portal containing action buttons from the datepicker.\n     * @param portal Portal to be removed.\n     */\n\n\n    removeActions(portal) {\n      if (portal === this._actionsPortal) {\n        this._actionsPortal = null;\n      }\n    }\n    /** Open the calendar. */\n\n\n    open() {\n      if (this._opened || this.disabled) {\n        return;\n      }\n\n      if (!this.datepickerInput && isDevMode()) {\n        throw Error('Attempted to open an MatDatepicker with no associated input.');\n      }\n\n      if (this._document) {\n        this._focusedElementBeforeOpen = this._document.activeElement;\n      }\n\n      this.touchUi ? this._openAsDialog() : this._openAsPopup();\n      this._opened = true;\n      this.openedStream.emit();\n    }\n    /** Close the calendar. */\n\n\n    close() {\n      if (!this._opened) {\n        return;\n      }\n\n      if (this._popupComponentRef && this._popupRef) {\n        const instance = this._popupComponentRef.instance;\n\n        instance._startExitAnimation();\n\n        instance._animationDone.pipe(take(1)).subscribe(() => this._destroyPopup());\n      }\n\n      if (this._dialogRef) {\n        this._dialogRef.close();\n\n        this._dialogRef = null;\n      }\n\n      const completeClose = () => {\n        // The `_opened` could've been reset already if\n        // we got two events in quick succession.\n        if (this._opened) {\n          this._opened = false;\n          this.closedStream.emit();\n          this._focusedElementBeforeOpen = null;\n        }\n      };\n\n      if (this._restoreFocus && this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {\n        // Because IE moves focus asynchronously, we can't count on it being restored before we've\n        // marked the datepicker as closed. If the event fires out of sequence and the element that\n        // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n        // able to close the calendar at all. We work around it by making the logic, that marks\n        // the datepicker as closed, async as well.\n        this._focusedElementBeforeOpen.focus();\n\n        setTimeout(completeClose);\n      } else {\n        completeClose();\n      }\n    }\n    /** Applies the current pending selection on the popup to the model. */\n\n\n    _applyPendingSelection() {\n      var _a, _b;\n\n      const instance = ((_a = this._popupComponentRef) === null || _a === void 0 ? void 0 : _a.instance) || ((_b = this._dialogRef) === null || _b === void 0 ? void 0 : _b.componentInstance);\n      instance === null || instance === void 0 ? void 0 : instance._applyPendingSelection();\n    }\n    /** Open the calendar as a dialog. */\n\n\n    _openAsDialog() {\n      // Usually this would be handled by `open` which ensures that we can only have one overlay\n      // open at a time, however since we reset the variables in async handlers some overlays\n      // may slip through if the user opens and closes multiple times in quick succession (e.g.\n      // by holding down the enter key).\n      if (this._dialogRef) {\n        this._dialogRef.close();\n      }\n\n      this._dialogRef = this._dialog.open(MatDatepickerContent, {\n        direction: this._dir ? this._dir.value : 'ltr',\n        viewContainerRef: this._viewContainerRef,\n        panelClass: 'mat-datepicker-dialog',\n        // These values are all the same as the defaults, but we set them explicitly so that the\n        // datepicker dialog behaves consistently even if the user changed the defaults.\n        hasBackdrop: true,\n        disableClose: false,\n        backdropClass: ['cdk-overlay-dark-backdrop', this._backdropHarnessClass],\n        width: '',\n        height: '',\n        minWidth: '',\n        minHeight: '',\n        maxWidth: '80vw',\n        maxHeight: '',\n        position: {},\n        // Disable the dialog's automatic focus capturing, because it'll go to the close button\n        // automatically. The calendar will move focus on its own once it renders.\n        autoFocus: false,\n        // `MatDialog` has focus restoration built in, however we want to disable it since the\n        // datepicker also has focus restoration for dropdown mode. We want to do this, in order\n        // to ensure that the timing is consistent between dropdown and dialog modes since `MatDialog`\n        // restores focus when the animation is finished, but the datepicker does it immediately.\n        // Furthermore, this avoids any conflicts where the datepicker consumer might move focus\n        // inside the `closed` event which is dispatched immediately.\n        restoreFocus: false\n      });\n\n      this._dialogRef.afterClosed().subscribe(() => this.close());\n\n      this._forwardContentValues(this._dialogRef.componentInstance);\n    }\n    /** Open the calendar as a popup. */\n\n\n    _openAsPopup() {\n      const portal = new ComponentPortal(MatDatepickerContent, this._viewContainerRef);\n\n      this._destroyPopup();\n\n      this._createPopup();\n\n      this._popupComponentRef = this._popupRef.attach(portal);\n\n      this._forwardContentValues(this._popupComponentRef.instance); // Update the position once the calendar has rendered.\n\n\n      this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n        this._popupRef.updatePosition();\n      });\n    }\n    /** Forwards relevant values from the datepicker to the datepicker content inside the overlay. */\n\n\n    _forwardContentValues(instance) {\n      instance.datepicker = this;\n      instance.color = this.color;\n      instance._actionsPortal = this._actionsPortal;\n    }\n    /** Create the popup. */\n\n\n    _createPopup() {\n      const positionStrategy = this._overlay.position().flexibleConnectedTo(this.datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn('.mat-datepicker-content').withFlexibleDimensions(false).withViewportMargin(8).withLockedPosition();\n\n      const overlayConfig = new OverlayConfig({\n        positionStrategy: this._setConnectedPositions(positionStrategy),\n        hasBackdrop: true,\n        backdropClass: ['mat-overlay-transparent-backdrop', this._backdropHarnessClass],\n        direction: this._dir,\n        scrollStrategy: this._scrollStrategy(),\n        panelClass: 'mat-datepicker-popup'\n      });\n      this._popupRef = this._overlay.create(overlayConfig);\n\n      this._popupRef.overlayElement.setAttribute('role', 'dialog');\n\n      merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(event => {\n        // Closing on alt + up is only valid when there's an input associated with the datepicker.\n        return event.keyCode === ESCAPE && !hasModifierKey(event) || this.datepickerInput && hasModifierKey(event, 'altKey') && event.keyCode === UP_ARROW;\n      }))).subscribe(event => {\n        if (event) {\n          event.preventDefault();\n        }\n\n        this.close();\n      });\n    }\n    /** Destroys the current popup overlay. */\n\n\n    _destroyPopup() {\n      if (this._popupRef) {\n        this._popupRef.dispose();\n\n        this._popupRef = this._popupComponentRef = null;\n      }\n    }\n    /** Sets the positions of the datepicker in dropdown mode based on the current configuration. */\n\n\n    _setConnectedPositions(strategy) {\n      const primaryX = this.xPosition === 'end' ? 'end' : 'start';\n      const secondaryX = primaryX === 'start' ? 'end' : 'start';\n      const primaryY = this.yPosition === 'above' ? 'bottom' : 'top';\n      const secondaryY = primaryY === 'top' ? 'bottom' : 'top';\n      return strategy.withPositions([{\n        originX: primaryX,\n        originY: secondaryY,\n        overlayX: primaryX,\n        overlayY: primaryY\n      }, {\n        originX: primaryX,\n        originY: primaryY,\n        overlayX: primaryX,\n        overlayY: secondaryY\n      }, {\n        originX: secondaryX,\n        originY: secondaryY,\n        overlayX: secondaryX,\n        overlayY: primaryY\n      }, {\n        originX: secondaryX,\n        originY: primaryY,\n        overlayX: secondaryX,\n        overlayY: secondaryY\n      }]);\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerBase.ɵfac = function MatDatepickerBase_Factory(t) {\n    return new (t || MatDatepickerBase)(i0.ɵɵdirectiveInject(i9$1.MatDialog), i0.ɵɵdirectiveInject(i10$1.Overlay), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(MAT_DATEPICKER_SCROLL_STRATEGY), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(i2.Directionality, 8), i0.ɵɵdirectiveInject(DOCUMENT, 8), i0.ɵɵdirectiveInject(MatDateSelectionModel));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDatepickerBase,\n    inputs: {\n      calendarHeaderComponent: \"calendarHeaderComponent\",\n      startAt: \"startAt\",\n      type: \"type\",\n      startView: \"startView\",\n      yearsPerPage: \"yearsPerPage\",\n      yearsPerRow: \"yearsPerRow\",\n      clockStep: \"clockStep\",\n      twelveHour: \"twelveHour\",\n      color: \"color\",\n      touchUi: \"touchUi\",\n      disabled: \"disabled\",\n      xPosition: \"xPosition\",\n      yPosition: \"yPosition\",\n      restoreFocus: \"restoreFocus\",\n      dateClass: \"dateClass\",\n      panelClass: \"panelClass\",\n      opened: \"opened\"\n    },\n    outputs: {\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      viewChanged: \"viewChanged\",\n      openedStream: \"opened\",\n      closedStream: \"closed\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return MatDatepickerBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(mmalerba): We use a component instead of a directive here so the user can use implicit\n// template reference variables (e.g. #d vs #d=\"matDatepicker\"). We can change this to a directive\n// if angular adds support for `exportAs: '$implicit'` on directives.\n\n/** Component responsible for managing the datepicker popup/dialog. */\n\n\nlet MatDatepicker = /*#__PURE__*/(() => {\n  class MatDatepicker extends MatDatepickerBase {}\n\n  /** @nocollapse */\n  MatDatepicker.ɵfac = /* @__PURE__ */function () {\n    let ɵMatDatepicker_BaseFactory;\n    return function MatDatepicker_Factory(t) {\n      return (ɵMatDatepicker_BaseFactory || (ɵMatDatepicker_BaseFactory = i0.ɵɵgetInheritedFactory(MatDatepicker)))(t || MatDatepicker);\n    };\n  }();\n  /** @nocollapse */\n\n\n  MatDatepicker.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatDatepicker,\n    selectors: [[\"mat-datepicker\"]],\n    exportAs: [\"matDatepicker\"],\n    features: [i0.ɵɵProvidersFeature([MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER, {\n      provide: MatDatepickerBase,\n      useExisting: MatDatepicker\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function MatDatepicker_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatepicker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An event used for datepicker input and change events. We don't always have access to a native\n * input or change event because the event may have been triggered by the user clicking on the\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\n */\n\n\nclass MatDatepickerInputEvent {\n  constructor(\n  /** Reference to the datepicker input component that emitted the event. */\n  target,\n  /** Reference to the native input element associated with the datepicker input. */\n  targetElement) {\n    this.target = target;\n    this.targetElement = targetElement;\n    this.value = this.target.value;\n  }\n\n}\n/** Base class for datepicker inputs. */\n\n\nlet MatDatepickerInputBase = /*#__PURE__*/(() => {\n  class MatDatepickerInputBase {\n    constructor(_elementRef, _dateAdapter, _dateFormats) {\n      this._elementRef = _elementRef;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      /** Emits when a `change` event is fired on this `<input>`. */\n\n      this.dateChange = new EventEmitter();\n      /** Emits when an `input` event is fired on this `<input>`. */\n\n      this.dateInput = new EventEmitter();\n      /** Emits when the internal state has changed */\n\n      this.stateChanges = new Subject();\n      this._type = 'date';\n\n      this._onTouched = () => {};\n\n      this._validatorOnChange = () => {};\n\n      this._cvaOnChange = () => {};\n\n      this._valueChangesSubscription = Subscription.EMPTY;\n      this._localeSubscription = Subscription.EMPTY;\n      /** The form control validator for whether the input parses. */\n\n      this._parseValidator = () => {\n        return this._lastValueValid ? null : {\n          'matDatepickerParse': {\n            'text': this._elementRef.nativeElement.value\n          }\n        };\n      };\n      /** The form control validator for the date filter. */\n\n\n      this._filterValidator = control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !controlValue || this._matchesFilter(controlValue) ? null : {\n          'matDatepickerFilter': true\n        };\n      };\n      /** The form control validator for the min date. */\n\n\n      this._minValidator = control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        const min = this._getMinDate();\n\n        return !min || !controlValue || this._dateAdapter.compareDate(min, controlValue) <= 0 ? null : {\n          'matDatepickerMin': {\n            'min': min,\n            'actual': controlValue\n          }\n        };\n      };\n      /** The form control validator for the max date. */\n\n\n      this._maxValidator = control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        const max = this._getMaxDate();\n\n        return !max || !controlValue || this._dateAdapter.compareDate(max, controlValue) >= 0 ? null : {\n          'matDatepickerMax': {\n            'max': max,\n            'actual': controlValue\n          }\n        };\n      };\n      /** Whether the last value set on the input was valid. */\n\n\n      this._lastValueValid = false;\n\n      if (isDevMode()) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      } // Update the displayed date when the locale changes.\n\n\n      this._localeSubscription = _dateAdapter.localeChanges.subscribe(() => {\n        this._assignValueProgrammatically(this.value);\n      });\n    }\n    /** The value of the input. */\n\n\n    get value() {\n      return this._model ? this._getValueFromModel(this._model.selection) : this._pendingValue;\n    }\n\n    set value(value) {\n      this._assignValueProgrammatically(value);\n    }\n    /** Whether the datepicker-input is disabled. */\n\n\n    get disabled() {\n      return !!this._disabled || this._parentDisabled();\n    }\n\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n      const element = this._elementRef.nativeElement;\n\n      if (this._disabled !== newValue) {\n        this._disabled = newValue;\n        this.stateChanges.next(undefined);\n      } // We need to null check the `blur` method, because it's undefined during SSR.\n      // In Ivy static bindings are invoked earlier, before the element is attached to the DOM.\n      // This can cause an error to be thrown in some browsers (IE/Edge) which assert that the\n      // element has been inserted.\n\n\n      if (newValue && this._isInitialized && element.blur) {\n        // Normally, native input elements automatically blur if they turn disabled. This behavior\n        // is problematic, because it would mean that it triggers another change detection cycle,\n        // which then causes a changed after checked error if the input element was focused before.\n        element.blur();\n      }\n    }\n    /** The type of value handled by the calendar. */\n\n\n    set type(type) {\n      this._type = type;\n\n      if (this.value) {\n        this._formatValue(this.value);\n      }\n    }\n    /** Gets the base validator functions. */\n\n\n    _getValidators() {\n      return [this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator];\n    }\n    /** Registers a date selection model with the input. */\n\n\n    _registerModel(model) {\n      this._model = model;\n\n      this._valueChangesSubscription.unsubscribe();\n\n      if (this._pendingValue) {\n        this._assignValue(this._pendingValue);\n      }\n\n      this._valueChangesSubscription = this._model.selectionChanged.subscribe(event => {\n        if (this._shouldHandleChangeEvent(event)) {\n          const value = this._getValueFromModel(event.selection);\n\n          this._lastValueValid = this._isValidValue(value);\n\n          this._cvaOnChange(value);\n\n          this._onTouched();\n\n          this._formatValue(value);\n\n          this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n          this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n        }\n      });\n    }\n\n    ngAfterViewInit() {\n      this._isInitialized = true;\n    }\n\n    ngOnChanges(changes) {\n      if (dateInputsHaveChanged(changes, this._dateAdapter, this.getUnit())) {\n        this.stateChanges.next(undefined);\n      }\n    }\n\n    ngOnDestroy() {\n      this._valueChangesSubscription.unsubscribe();\n\n      this._localeSubscription.unsubscribe();\n\n      this.stateChanges.complete();\n    }\n\n    getUnit() {\n      switch (this._type) {\n        case 'date':\n          return 'day';\n\n        case 'datetime':\n        case 'time':\n          return 'minute';\n\n        default:\n          return this._type;\n      }\n    }\n    /** @docs-private */\n\n\n    registerOnValidatorChange(fn) {\n      this._validatorOnChange = fn;\n    }\n    /** @docs-private */\n\n\n    validate(c) {\n      return this._validator ? this._validator(c) : null;\n    } // Implemented as part of ControlValueAccessor.\n\n\n    writeValue(value) {\n      this._assignValueProgrammatically(value);\n    } // Implemented as part of ControlValueAccessor.\n\n\n    registerOnChange(fn) {\n      this._cvaOnChange = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n    _onKeydown(event) {\n      const isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;\n\n      if (isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\n        this._openPopup();\n\n        event.preventDefault();\n      }\n    }\n\n    _onInput(value) {\n      const lastValueWasValid = this._lastValueValid;\n\n      let date = this._dateAdapter.parse(value, this._dateFormats.parse[`${this._type}Input`]);\n\n      this._lastValueValid = this._isValidValue(date);\n      date = this._dateAdapter.getValidDateOrNull(date);\n\n      if (!this._dateAdapter.sameDate(date, this.value, this.getUnit())) {\n        this._assignValue(date);\n\n        this._cvaOnChange(date);\n\n        this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n      } else {\n        // Call the CVA change handler for invalid values\n        // since this is what marks the control as dirty.\n        if (value && !this.value) {\n          this._cvaOnChange(date);\n        }\n\n        if (lastValueWasValid !== this._lastValueValid) {\n          this._validatorOnChange();\n        }\n      }\n    }\n\n    _onChange() {\n      this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n    }\n    /** Handles blur events on the input. */\n\n\n    _onBlur() {\n      // Reformat the input only if we have a valid value.\n      if (this.value) {\n        this._formatValue(this.value);\n      }\n\n      this._onTouched();\n    }\n    /** Formats a value and sets it on the input element. */\n\n\n    _formatValue(value) {\n      this._elementRef.nativeElement.value = value ? this._dateAdapter.format(value, this._dateFormats.display[`${this._type}Input`]) : '';\n    }\n    /** Assigns a value to the model. */\n\n\n    _assignValue(value) {\n      // We may get some incoming values before the model was\n      // assigned. Save the value so that we can assign it later.\n      if (this._model) {\n        this._assignValueToModel(value);\n\n        this._pendingValue = null;\n      } else {\n        this._pendingValue = value;\n      }\n    }\n    /** Whether a value is considered valid. */\n\n\n    _isValidValue(value) {\n      return !value || this._dateAdapter.isValid(value);\n    }\n    /**\n     * Checks whether a parent control is disabled. This is in place so that it can be overridden\n     * by inputs extending this one which can be placed inside of a group that can be disabled.\n     */\n\n\n    _parentDisabled() {\n      return false;\n    }\n    /** Programmatically assigns a value to the input. */\n\n\n    _assignValueProgrammatically(value) {\n      value = this._dateAdapter.deserialize(value);\n      this._lastValueValid = this._isValidValue(value);\n      value = this._dateAdapter.getValidDateOrNull(value);\n\n      this._assignValue(value);\n\n      this._formatValue(value);\n    }\n    /** Gets whether a value matches the current date filter. */\n\n\n    _matchesFilter(value) {\n      const filter = this._getDateFilter();\n\n      return !filter || filter(value);\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerInputBase.ɵfac = function MatDatepickerInputBase_Factory(t) {\n    return new (t || MatDatepickerInputBase)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerInputBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDatepickerInputBase,\n    inputs: {\n      value: \"value\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      dateChange: \"dateChange\",\n      dateInput: \"dateInput\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return MatDatepickerInputBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Checks whether the `SimpleChanges` object from an `ngOnChanges`\n * callback has any changes, accounting for date objects.\n */\n\n\nfunction dateInputsHaveChanged(changes, adapter, unit = 'minute') {\n  const keys = Object.keys(changes);\n\n  for (let key of keys) {\n    const {\n      previousValue,\n      currentValue\n    } = changes[key];\n\n    if (adapter.isDateInstance(previousValue) && adapter.isDateInstance(currentValue)) {\n      if (!adapter.sameDate(previousValue, currentValue, unit)) {\n        return true;\n      }\n    } else {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\n\n\nconst MAT_DATEPICKER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatDatepickerInput),\n  multi: true\n};\n/** @docs-private */\n\nconst MAT_DATEPICKER_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MatDatepickerInput),\n  multi: true\n};\n/** Directive used to connect an input to a MatDatepicker. */\n\nlet MatDatepickerInput = /*#__PURE__*/(() => {\n  class MatDatepickerInput extends MatDatepickerInputBase {\n    constructor(elementRef, dateAdapter, dateFormats, _formField) {\n      super(elementRef, dateAdapter, dateFormats);\n      this._formField = _formField;\n      this._closedSubscription = Subscription.EMPTY;\n      this._validator = Validators.compose(super._getValidators());\n    }\n    /** The datepicker that this input is associated with. */\n\n\n    set matDatepicker(datepicker) {\n      if (datepicker) {\n        this._datepicker = datepicker;\n        this._closedSubscription = datepicker.closedStream.subscribe(() => this._onTouched());\n\n        this._registerModel(datepicker.registerInput(this));\n      }\n    }\n    /** The minimum valid date. */\n\n\n    get min() {\n      return this._min;\n    }\n\n    set min(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      if (!this._dateAdapter.sameDate(validValue, this._min, this.getUnit())) {\n        this._min = validValue;\n\n        this._validatorOnChange();\n      }\n    }\n    /** The maximum valid date. */\n\n\n    get max() {\n      return this._max;\n    }\n\n    set max(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      if (!this._dateAdapter.sameDate(validValue, this._max, this.getUnit())) {\n        this._max = validValue;\n\n        this._validatorOnChange();\n      }\n    }\n    /** Function that can be used to filter out dates within the datepicker. */\n\n\n    get dateFilter() {\n      return this._dateFilter;\n    }\n\n    set dateFilter(value) {\n      const wasMatchingValue = this._matchesFilter(this.value);\n\n      this._dateFilter = value;\n\n      if (this._matchesFilter(this.value) !== wasMatchingValue) {\n        this._validatorOnChange();\n      }\n    }\n    /**\n     * Gets the element that the datepicker popup should be connected to.\n     * @return The element to connect the popup to.\n     */\n\n\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    }\n    /** Returns the palette used by the input's form field, if any. */\n\n\n    getThemePalette() {\n      return this._formField ? this._formField.color : undefined;\n    }\n    /** Gets the value at which the calendar should start. */\n\n\n    getStartValue() {\n      return this.value;\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      this._closedSubscription.unsubscribe();\n    }\n    /** Opens the associated datepicker. */\n\n\n    _openPopup() {\n      if (this._datepicker) {\n        this._datepicker.open();\n      }\n    }\n\n    _getValueFromModel(modelValue) {\n      return modelValue;\n    }\n\n    _assignValueToModel(value) {\n      if (this._model) {\n        this._model.updateSelection(value, this);\n      }\n    }\n    /** Gets the input's minimum date. */\n\n\n    _getMinDate() {\n      return this._min;\n    }\n    /** Gets the input's maximum date. */\n\n\n    _getMaxDate() {\n      return this._max;\n    }\n    /** Gets the input's date filtering function. */\n\n\n    _getDateFilter() {\n      return this._dateFilter;\n    }\n\n    _shouldHandleChangeEvent(event) {\n      return event.source !== this;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerInput.ɵfac = function MatDatepickerInput_Factory(t) {\n    return new (t || MatDatepickerInput)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), i0.ɵɵdirectiveInject(MAT_FORM_FIELD, 8));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerInput.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDatepickerInput,\n    selectors: [[\"input\", \"matDatepicker\", \"\"]],\n    hostAttrs: [1, \"mat-datepicker-input\"],\n    hostVars: 6,\n    hostBindings: function MatDatepickerInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function MatDatepickerInput_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function MatDatepickerInput_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"blur\", function MatDatepickerInput_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        })(\"keydown\", function MatDatepickerInput_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-haspopup\", ctx._datepicker ? \"dialog\" : null)(\"aria-owns\", (ctx._datepicker == null ? null : ctx._datepicker.opened) && ctx._datepicker.id || null)(\"min\", ctx.min ? ctx._dateAdapter.toIso8601(ctx.min) : null)(\"max\", ctx.max ? ctx._dateAdapter.toIso8601(ctx.max) : null)(\"data-mat-calendar\", ctx._datepicker ? ctx._datepicker.id : null);\n      }\n    },\n    inputs: {\n      matDatepicker: \"matDatepicker\",\n      min: \"min\",\n      max: \"max\",\n      dateFilter: [\"matDatepickerFilter\", \"dateFilter\"]\n    },\n    exportAs: [\"matDatepickerInput\"],\n    features: [i0.ɵɵProvidersFeature([MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, {\n      provide: MAT_INPUT_VALUE_ACCESSOR,\n      useExisting: MatDatepickerInput\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return MatDatepickerInput;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Can be used to override the icon of a `matDatepickerToggle`. */\n\n\nlet MatDatepickerToggleIcon = /*#__PURE__*/(() => {\n  class MatDatepickerToggleIcon {}\n\n  /** @nocollapse */\n  MatDatepickerToggleIcon.ɵfac = function MatDatepickerToggleIcon_Factory(t) {\n    return new (t || MatDatepickerToggleIcon)();\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerToggleIcon.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDatepickerToggleIcon,\n    selectors: [[\"\", \"matDatepickerToggleIcon\", \"\"]]\n  });\n  return MatDatepickerToggleIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MatDatepickerToggle = /*#__PURE__*/(() => {\n  class MatDatepickerToggle {\n    constructor(_intl, _changeDetectorRef, defaultTabIndex) {\n      this._intl = _intl;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._stateChanges = Subscription.EMPTY;\n      const parsedTabIndex = Number(defaultTabIndex);\n      this.tabIndex = parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;\n    }\n    /** Whether the toggle button is disabled. */\n\n\n    get disabled() {\n      if (this._disabled === undefined && this.datepicker) {\n        return this.datepicker.disabled;\n      }\n\n      return !!this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n\n    ngOnChanges(changes) {\n      if (changes['datepicker']) {\n        this._watchStateChanges();\n      }\n    }\n\n    ngOnDestroy() {\n      this._stateChanges.unsubscribe();\n    }\n\n    ngAfterContentInit() {\n      this._watchStateChanges();\n    }\n\n    _open(event) {\n      if (this.datepicker && !this.disabled) {\n        this.datepicker.open();\n        event.stopPropagation();\n      }\n    }\n\n    _watchStateChanges() {\n      var _a, _b, _c;\n\n      const datepickerStateChanged = ((_a = this.datepicker) === null || _a === void 0 ? void 0 : _a.stateChanges) || of();\n      const inputStateChanged = ((_c = (_b = this.datepicker) === null || _b === void 0 ? void 0 : _b.datepickerInput) === null || _c === void 0 ? void 0 : _c.stateChanges) || of();\n      const datepickerToggled = this.datepicker ? merge(this.datepicker.openedStream, this.datepicker.closedStream) : of();\n\n      this._stateChanges.unsubscribe();\n\n      this._stateChanges = merge(this._intl.changes, datepickerStateChanged, inputStateChanged, datepickerToggled).subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerToggle.ɵfac = function MatDatepickerToggle_Factory(t) {\n    return new (t || MatDatepickerToggle)(i0.ɵɵdirectiveInject(MatDatepickerIntl), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵinjectAttribute('tabindex'));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerToggle.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatDatepickerToggle,\n    selectors: [[\"mat-datepicker-toggle\"]],\n    contentQueries: function MatDatepickerToggle_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, MatDatepickerToggleIcon, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._customIcon = _t.first);\n      }\n    },\n    viewQuery: function MatDatepickerToggle_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._button = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-datepicker-toggle\"],\n    hostVars: 8,\n    hostBindings: function MatDatepickerToggle_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function MatDatepickerToggle_click_HostBindingHandler($event) {\n          return ctx._open($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", null)(\"data-mat-calendar\", ctx.datepicker ? ctx.datepicker.id : null);\n        i0.ɵɵclassProp(\"mat-datepicker-toggle-active\", ctx.datepicker && ctx.datepicker.opened)(\"mat-accent\", ctx.datepicker && ctx.datepicker.color === \"accent\")(\"mat-warn\", ctx.datepicker && ctx.datepicker.color === \"warn\");\n      }\n    },\n    inputs: {\n      datepicker: [\"for\", \"datepicker\"],\n      tabIndex: \"tabIndex\",\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      disabled: \"disabled\",\n      disableRipple: \"disableRipple\"\n    },\n    exportAs: [\"matDatepickerToggle\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c8,\n    decls: 4,\n    vars: 6,\n    consts: [[\"mat-icon-button\", \"\", \"type\", \"button\", 3, \"disabled\", \"disableRipple\"], [\"button\", \"\"], [\"class\", \"mat-datepicker-toggle-default-icon\", \"viewBox\", \"0 0 24 24\", \"width\", \"24px\", \"height\", \"24px\", \"fill\", \"currentColor\", \"focusable\", \"false\", 4, \"ngIf\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"24px\", \"height\", \"24px\", \"fill\", \"currentColor\", \"focusable\", \"false\", 1, \"mat-datepicker-toggle-default-icon\"], [\"d\", \"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"]],\n    template: function MatDatepickerToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c7);\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵtemplate(2, MatDatepickerToggle__svg_svg_2_Template, 2, 0, \"svg\", 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"disabled\", ctx.disabled)(\"disableRipple\", ctx.disableRipple);\n        i0.ɵɵattribute(\"aria-haspopup\", ctx.datepicker ? \"dialog\" : null)(\"aria-label\", ctx.ariaLabel || ctx._intl.openCalendarLabel)(\"tabindex\", ctx.disabled ? -1 : ctx.tabIndex);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx._customIcon);\n      }\n    },\n    directives: [i3.MatButton, i4.NgIf],\n    styles: [\".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatepickerToggle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to provide the date range input wrapper component\n * to the parts without circular dependencies.\n */\n\n\nconst MAT_DATE_RANGE_INPUT_PARENT = new InjectionToken('MAT_DATE_RANGE_INPUT_PARENT');\n/**\n * Base class for the individual inputs that can be projected inside a `mat-date-range-input`.\n */\n\nlet MatDateRangeInputPartBase = /*#__PURE__*/(() => {\n  class MatDateRangeInputPartBase extends MatDatepickerInputBase {\n    constructor(_rangeInput, elementRef, _defaultErrorStateMatcher, _injector, _parentForm, _parentFormGroup, dateAdapter, dateFormats) {\n      super(elementRef, dateAdapter, dateFormats);\n      this._rangeInput = _rangeInput;\n      this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n      this._injector = _injector;\n      this._parentForm = _parentForm;\n      this._parentFormGroup = _parentFormGroup;\n    }\n\n    ngOnInit() {\n      // We need the date input to provide itself as a `ControlValueAccessor` and a `Validator`, while\n      // injecting its `NgControl` so that the error state is handled correctly. This introduces a\n      // circular dependency, because both `ControlValueAccessor` and `Validator` depend on the input\n      // itself. Usually we can work around it for the CVA, but there's no API to do it for the\n      // validator. We work around it here by injecting the `NgControl` in `ngOnInit`, after\n      // everything has been resolved.\n      const ngControl = this._injector.get(NgControl, null, InjectFlags.Self);\n\n      if (ngControl) {\n        this.ngControl = ngControl;\n      }\n    }\n\n    ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n      }\n    }\n    /** Gets whether the input is empty. */\n\n\n    isEmpty() {\n      return this._elementRef.nativeElement.value.length === 0;\n    }\n    /** Gets the placeholder of the input. */\n\n\n    _getPlaceholder() {\n      return this._elementRef.nativeElement.placeholder;\n    }\n    /** Focuses the input. */\n\n\n    focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /** Handles `input` events on the input element. */\n\n\n    _onInput(value) {\n      super._onInput(value);\n\n      this._rangeInput._handleChildValueChange();\n    }\n    /** Opens the datepicker associated with the input. */\n\n\n    _openPopup() {\n      this._rangeInput._openDatepicker();\n    }\n    /** Gets the minimum date from the range input. */\n\n\n    _getMinDate() {\n      return this._rangeInput.min;\n    }\n    /** Gets the maximum date from the range input. */\n\n\n    _getMaxDate() {\n      return this._rangeInput.max;\n    }\n    /** Gets the date filter function from the range input. */\n\n\n    _getDateFilter() {\n      return this._rangeInput.dateFilter;\n    }\n\n    _parentDisabled() {\n      return this._rangeInput._groupDisabled;\n    }\n\n    _shouldHandleChangeEvent({\n      source\n    }) {\n      return source !== this._rangeInput._startInput && source !== this._rangeInput._endInput;\n    }\n\n    _assignValueProgrammatically(value) {\n      super._assignValueProgrammatically(value);\n\n      const opposite = this === this._rangeInput._startInput ? this._rangeInput._endInput : this._rangeInput._startInput;\n      opposite === null || opposite === void 0 ? void 0 : opposite._validatorOnChange();\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDateRangeInputPartBase.ɵfac = function MatDateRangeInputPartBase_Factory(t) {\n    return new (t || MatDateRangeInputPartBase)(i0.ɵɵdirectiveInject(MAT_DATE_RANGE_INPUT_PARENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.ErrorStateMatcher), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i2$2.NgForm, 8), i0.ɵɵdirectiveInject(i2$2.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8));\n  };\n  /** @nocollapse */\n\n\n  MatDateRangeInputPartBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDateRangeInputPartBase,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return MatDateRangeInputPartBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst _MatDateRangeInputBase = // Needs to be `as any`, because the base class is abstract.\nmixinErrorState(MatDateRangeInputPartBase);\n/** Input for entering the start date in a `mat-date-range-input`. */\n\n\nlet MatStartDate = /*#__PURE__*/(() => {\n  class MatStartDate extends _MatDateRangeInputBase {\n    constructor(rangeInput, elementRef, defaultErrorStateMatcher, injector, parentForm, parentFormGroup, dateAdapter, dateFormats) {\n      // TODO(crisbeto): this constructor shouldn't be necessary, but ViewEngine doesn't seem to\n      // handle DI correctly when it is inherited from `MatDateRangeInputPartBase`. We can drop this\n      // constructor once ViewEngine is removed.\n      super(rangeInput, elementRef, defaultErrorStateMatcher, injector, parentForm, parentFormGroup, dateAdapter, dateFormats);\n      /** Validator that checks that the start date isn't after the end date. */\n\n      this._startValidator = control => {\n        const start = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        const end = this._model ? this._model.selection.end : null;\n        return !start || !end || this._dateAdapter.compareDate(start, end) <= 0 ? null : {\n          'matStartDateInvalid': {\n            'end': end,\n            'actual': start\n          }\n        };\n      };\n\n      this._validator = Validators.compose([...super._getValidators(), this._startValidator]);\n    }\n\n    ngOnInit() {\n      // Normally this happens automatically, but it seems to break if not added explicitly when all\n      // of the criteria below are met:\n      // 1) The class extends a TS mixin.\n      // 2) The application is running in ViewEngine.\n      // 3) The application is being transpiled through tsickle.\n      // This can be removed once google3 is completely migrated to Ivy.\n      super.ngOnInit();\n    }\n\n    ngDoCheck() {\n      // Normally this happens automatically, but it seems to break if not added explicitly when all\n      // of the criteria below are met:\n      // 1) The class extends a TS mixin.\n      // 2) The application is running in ViewEngine.\n      // 3) The application is being transpiled through tsickle.\n      // This can be removed once google3 is completely migrated to Ivy.\n      super.ngDoCheck();\n    }\n\n    _getValueFromModel(modelValue) {\n      return modelValue.start;\n    }\n\n    _assignValueToModel(value) {\n      if (this._model) {\n        const range = new DateRange(value, this._model.selection.end);\n\n        this._model.updateSelection(range, this);\n      }\n    }\n\n    _formatValue(value) {\n      super._formatValue(value); // Any time the input value is reformatted we need to tell the parent.\n\n\n      this._rangeInput._handleChildValueChange();\n    }\n    /** Gets the value that should be used when mirroring the input's size. */\n\n\n    getMirrorValue() {\n      const element = this._elementRef.nativeElement;\n      const value = element.value;\n      return value.length > 0 ? value : element.placeholder;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatStartDate.ɵfac = function MatStartDate_Factory(t) {\n    return new (t || MatStartDate)(i0.ɵɵdirectiveInject(MAT_DATE_RANGE_INPUT_PARENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.ErrorStateMatcher), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i2$2.NgForm, 8), i0.ɵɵdirectiveInject(i2$2.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8));\n  };\n  /** @nocollapse */\n\n\n  MatStartDate.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatStartDate,\n    selectors: [[\"input\", \"matStartDate\", \"\"]],\n    hostAttrs: [\"type\", \"text\", 1, \"mat-start-date\", \"mat-date-range-input-inner\"],\n    hostVars: 6,\n    hostBindings: function MatStartDate_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function MatStartDate_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function MatStartDate_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"keydown\", function MatStartDate_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        })(\"blur\", function MatStartDate_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"id\", ctx._rangeInput.id)(\"aria-haspopup\", ctx._rangeInput.rangePicker ? \"dialog\" : null)(\"aria-owns\", (ctx._rangeInput.rangePicker == null ? null : ctx._rangeInput.rangePicker.opened) && ctx._rangeInput.rangePicker.id || null)(\"min\", ctx._getMinDate() ? ctx._dateAdapter.toIso8601(ctx._getMinDate()) : null)(\"max\", ctx._getMaxDate() ? ctx._dateAdapter.toIso8601(ctx._getMaxDate()) : null);\n      }\n    },\n    inputs: {\n      errorStateMatcher: \"errorStateMatcher\"\n    },\n    outputs: {\n      dateChange: \"dateChange\",\n      dateInput: \"dateInput\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: MatStartDate,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: MatStartDate,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return MatStartDate;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Input for entering the end date in a `mat-date-range-input`. */\n\n\nlet MatEndDate = /*#__PURE__*/(() => {\n  class MatEndDate extends _MatDateRangeInputBase {\n    constructor(rangeInput, elementRef, defaultErrorStateMatcher, injector, parentForm, parentFormGroup, dateAdapter, dateFormats) {\n      // TODO(crisbeto): this constructor shouldn't be necessary, but ViewEngine doesn't seem to\n      // handle DI correctly when it is inherited from `MatDateRangeInputPartBase`. We can drop this\n      // constructor once ViewEngine is removed.\n      super(rangeInput, elementRef, defaultErrorStateMatcher, injector, parentForm, parentFormGroup, dateAdapter, dateFormats);\n      /** Validator that checks that the end date isn't before the start date. */\n\n      this._endValidator = control => {\n        const end = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        const start = this._model ? this._model.selection.start : null;\n        return !end || !start || this._dateAdapter.compareDate(end, start) >= 0 ? null : {\n          'matEndDateInvalid': {\n            'start': start,\n            'actual': end\n          }\n        };\n      };\n\n      this._validator = Validators.compose([...super._getValidators(), this._endValidator]);\n    }\n\n    ngOnInit() {\n      // Normally this happens automatically, but it seems to break if not added explicitly when all\n      // of the criteria below are met:\n      // 1) The class extends a TS mixin.\n      // 2) The application is running in ViewEngine.\n      // 3) The application is being transpiled through tsickle.\n      // This can be removed once google3 is completely migrated to Ivy.\n      super.ngOnInit();\n    }\n\n    ngDoCheck() {\n      // Normally this happens automatically, but it seems to break if not added explicitly when all\n      // of the criteria below are met:\n      // 1) The class extends a TS mixin.\n      // 2) The application is running in ViewEngine.\n      // 3) The application is being transpiled through tsickle.\n      // This can be removed once google3 is completely migrated to Ivy.\n      super.ngDoCheck();\n    }\n\n    _getValueFromModel(modelValue) {\n      return modelValue.end;\n    }\n\n    _assignValueToModel(value) {\n      if (this._model) {\n        const range = new DateRange(this._model.selection.start, value);\n\n        this._model.updateSelection(range, this);\n      }\n    }\n\n    _onKeydown(event) {\n      // If the user is pressing backspace on an empty end input, move focus back to the start.\n      if (event.keyCode === BACKSPACE && !this._elementRef.nativeElement.value) {\n        this._rangeInput._startInput.focus();\n      }\n\n      super._onKeydown(event);\n    }\n\n  }\n\n  /** @nocollapse */\n  MatEndDate.ɵfac = function MatEndDate_Factory(t) {\n    return new (t || MatEndDate)(i0.ɵɵdirectiveInject(MAT_DATE_RANGE_INPUT_PARENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.ErrorStateMatcher), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i2$2.NgForm, 8), i0.ɵɵdirectiveInject(i2$2.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8));\n  };\n  /** @nocollapse */\n\n\n  MatEndDate.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatEndDate,\n    selectors: [[\"input\", \"matEndDate\", \"\"]],\n    hostAttrs: [\"type\", \"text\", 1, \"mat-end-date\", \"mat-date-range-input-inner\"],\n    hostVars: 5,\n    hostBindings: function MatEndDate_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function MatEndDate_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function MatEndDate_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"keydown\", function MatEndDate_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        })(\"blur\", function MatEndDate_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-haspopup\", ctx._rangeInput.rangePicker ? \"dialog\" : null)(\"aria-owns\", (ctx._rangeInput.rangePicker == null ? null : ctx._rangeInput.rangePicker.opened) && ctx._rangeInput.rangePicker.id || null)(\"min\", ctx._getMinDate() ? ctx._dateAdapter.toIso8601(ctx._getMinDate()) : null)(\"max\", ctx._getMaxDate() ? ctx._dateAdapter.toIso8601(ctx._getMaxDate()) : null);\n      }\n    },\n    inputs: {\n      errorStateMatcher: \"errorStateMatcher\"\n    },\n    outputs: {\n      dateChange: \"dateChange\",\n      dateInput: \"dateInput\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: MatEndDate,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: MatEndDate,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return MatEndDate;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet nextUniqueId = 0;\nlet MatDateRangeInput = /*#__PURE__*/(() => {\n  class MatDateRangeInput {\n    constructor(_changeDetectorRef, _elementRef, control, _dateAdapter, _formField) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._elementRef = _elementRef;\n      this._dateAdapter = _dateAdapter;\n      this._formField = _formField;\n      this._closedSubscription = Subscription.EMPTY;\n      /** Unique ID for the input. */\n\n      this.id = `mat-date-range-input-${nextUniqueId++}`;\n      /** Whether the control is focused. */\n\n      this.focused = false;\n      /** Name of the form control. */\n\n      this.controlType = 'mat-date-range-input';\n      this._groupDisabled = false;\n      /** Value for the `aria-describedby` attribute of the inputs. */\n\n      this._ariaDescribedBy = null;\n      /** Separator text to be shown between the inputs. */\n\n      this.separator = '–';\n      /** Start of the comparison range that should be shown in the calendar. */\n\n      this.comparisonStart = null;\n      /** End of the comparison range that should be shown in the calendar. */\n\n      this.comparisonEnd = null;\n      /** Emits when the input's state has changed. */\n\n      this.stateChanges = new Subject();\n\n      if (!_dateAdapter && isDevMode()) {\n        throw createMissingDateImplError('DateAdapter');\n      } // TODO(crisbeto): remove `as any` after #18206 lands.\n\n\n      this.ngControl = control;\n    }\n    /** Current value of the range input. */\n\n\n    get value() {\n      return this._model ? this._model.selection : null;\n    }\n    /** Whether the control's label should float. */\n\n\n    get shouldLabelFloat() {\n      return this.focused || !this.empty;\n    }\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * Set the placeholder attribute on `matStartDate` and `matEndDate`.\n     * @docs-private\n     */\n\n\n    get placeholder() {\n      var _a, _b;\n\n      const start = ((_a = this._startInput) === null || _a === void 0 ? void 0 : _a._getPlaceholder()) || '';\n      const end = ((_b = this._endInput) === null || _b === void 0 ? void 0 : _b._getPlaceholder()) || '';\n      return start || end ? `${start} ${this.separator} ${end}` : '';\n    }\n    /** The range picker that this input is associated with. */\n\n\n    get rangePicker() {\n      return this._rangePicker;\n    }\n\n    set rangePicker(rangePicker) {\n      if (rangePicker) {\n        this._model = rangePicker.registerInput(this);\n        this._rangePicker = rangePicker;\n\n        this._closedSubscription.unsubscribe();\n\n        this._closedSubscription = rangePicker.closedStream.subscribe(() => {\n          var _a, _b;\n\n          (_a = this._startInput) === null || _a === void 0 ? void 0 : _a._onTouched();\n          (_b = this._endInput) === null || _b === void 0 ? void 0 : _b._onTouched();\n        });\n\n        this._registerModel(this._model);\n      }\n    }\n    /** Whether the input is required. */\n\n\n    get required() {\n      return !!this._required;\n    }\n\n    set required(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    /** Function that can be used to filter out dates within the date range picker. */\n\n\n    get dateFilter() {\n      return this._dateFilter;\n    }\n\n    set dateFilter(value) {\n      const start = this._startInput;\n      const end = this._endInput;\n      const wasMatchingStart = start === null || start === void 0 ? void 0 : start._matchesFilter(start.value);\n      const wasMatchingEnd = end === null || end === void 0 ? void 0 : end._matchesFilter(start.value);\n      this._dateFilter = value;\n\n      if ((start === null || start === void 0 ? void 0 : start._matchesFilter(start.value)) !== wasMatchingStart) {\n        start._validatorOnChange();\n      }\n\n      if ((end === null || end === void 0 ? void 0 : end._matchesFilter(end.value)) !== wasMatchingEnd) {\n        end._validatorOnChange();\n      }\n    }\n    /** The minimum valid date. */\n\n\n    get min() {\n      return this._min;\n    }\n\n    set min(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      if (!this._dateAdapter.sameDate(validValue, this._min)) {\n        this._min = validValue;\n\n        this._revalidate();\n      }\n    }\n    /** The maximum valid date. */\n\n\n    get max() {\n      return this._max;\n    }\n\n    set max(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      if (!this._dateAdapter.sameDate(validValue, this._max)) {\n        this._max = validValue;\n\n        this._revalidate();\n      }\n    }\n    /** Whether the input is disabled. */\n\n\n    get disabled() {\n      var _a, _b;\n\n      return ((_a = this._startInput) === null || _a === void 0 ? void 0 : _a.disabled) && ((_b = this._endInput) === null || _b === void 0 ? void 0 : _b.disabled) || this._groupDisabled;\n    }\n\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._groupDisabled) {\n        this._groupDisabled = newValue;\n        this.stateChanges.next(undefined);\n      }\n    }\n    /** Whether the input is in an error state. */\n\n\n    get errorState() {\n      var _a, _b;\n\n      return ((_a = this._startInput) === null || _a === void 0 ? void 0 : _a.errorState) || ((_b = this._endInput) === null || _b === void 0 ? void 0 : _b.errorState) || false;\n    }\n    /** Whether the datepicker input is empty. */\n\n\n    get empty() {\n      const startEmpty = this._startInput ? this._startInput.isEmpty() : false;\n      const endEmpty = this._endInput ? this._endInput.isEmpty() : false;\n      return startEmpty && endEmpty;\n    }\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * @docs-private\n     */\n\n\n    setDescribedByIds(ids) {\n      this._ariaDescribedBy = ids.length ? ids.join(' ') : null;\n    }\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * @docs-private\n     */\n\n\n    onContainerClick() {\n      if (!this.focused && !this.disabled) {\n        if (!this._model || !this._model.selection.start) {\n          this._startInput.focus();\n        } else {\n          this._endInput.focus();\n        }\n      }\n    }\n\n    ngAfterContentInit() {\n      if (isDevMode()) {\n        if (!this._startInput) {\n          throw Error('mat-date-range-input must contain a matStartDate input');\n        }\n\n        if (!this._endInput) {\n          throw Error('mat-date-range-input must contain a matEndDate input');\n        }\n      }\n\n      if (this._model) {\n        this._registerModel(this._model);\n      } // We don't need to unsubscribe from this, because we\n      // know that the input streams will be completed on destroy.\n\n\n      merge(this._startInput.stateChanges, this._endInput.stateChanges).subscribe(() => {\n        this.stateChanges.next(undefined);\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (dateInputsHaveChanged(changes, this._dateAdapter, 'day')) {\n        this.stateChanges.next(undefined);\n      }\n    }\n\n    ngOnDestroy() {\n      this._closedSubscription.unsubscribe();\n\n      this.stateChanges.complete();\n    }\n    /** Gets the date at which the calendar should start. */\n\n\n    getStartValue() {\n      return this.value ? this.value.start : null;\n    }\n    /** Gets the input's theme palette. */\n\n\n    getThemePalette() {\n      return this._formField ? this._formField.color : undefined;\n    }\n    /** Gets the element to which the calendar overlay should be attached. */\n\n\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    }\n    /** Gets the value that is used to mirror the state input. */\n\n\n    _getInputMirrorValue() {\n      return this._startInput ? this._startInput.getMirrorValue() : '';\n    }\n    /** Whether the input placeholders should be hidden. */\n\n\n    _shouldHidePlaceholders() {\n      return this._startInput ? !this._startInput.isEmpty() : false;\n    }\n    /** Handles the value in one of the child inputs changing. */\n\n\n    _handleChildValueChange() {\n      this.stateChanges.next(undefined);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Opens the date range picker associated with the input. */\n\n\n    _openDatepicker() {\n      if (this._rangePicker) {\n        this._rangePicker.open();\n      }\n    }\n    /** Whether the separate text should be hidden. */\n\n\n    _shouldHideSeparator() {\n      return (!this._formField || this._formField._hideControlPlaceholder()) && this.empty;\n    }\n    /** Gets the value for the `aria-labelledby` attribute of the inputs. */\n\n\n    _getAriaLabelledby() {\n      var _a;\n\n      return ((_a = this._formField) === null || _a === void 0 ? void 0 : _a._hasFloatingLabel()) ? this._formField._labelId : null;\n    }\n    /** Re-runs the validators on the start/end inputs. */\n\n\n    _revalidate() {\n      if (this._startInput) {\n        this._startInput._validatorOnChange();\n      }\n\n      if (this._endInput) {\n        this._endInput._validatorOnChange();\n      }\n    }\n    /** Registers the current date selection model with the start/end inputs. */\n\n\n    _registerModel(model) {\n      if (this._startInput) {\n        this._startInput._registerModel(model);\n      }\n\n      if (this._endInput) {\n        this._endInput._registerModel(model);\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDateRangeInput.ɵfac = function MatDateRangeInput_Factory(t) {\n    return new (t || MatDateRangeInput)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2$2.ControlContainer, 10), i0.ɵɵdirectiveInject(i1.DateAdapter, 8), i0.ɵɵdirectiveInject(MAT_FORM_FIELD, 8));\n  };\n  /** @nocollapse */\n\n\n  MatDateRangeInput.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatDateRangeInput,\n    selectors: [[\"mat-date-range-input\"]],\n    contentQueries: function MatDateRangeInput_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, MatStartDate, 5);\n        i0.ɵɵcontentQuery(dirIndex, MatEndDate, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._startInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._endInput = _t.first);\n      }\n    },\n    hostAttrs: [\"role\", \"group\", 1, \"mat-date-range-input\"],\n    hostVars: 8,\n    hostBindings: function MatDateRangeInput_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", null)(\"aria-labelledby\", ctx._getAriaLabelledby())(\"aria-describedby\", ctx._ariaDescribedBy)(\"data-mat-calendar\", ctx.rangePicker ? ctx.rangePicker.id : null);\n        i0.ɵɵclassProp(\"mat-date-range-input-hide-placeholders\", ctx._shouldHidePlaceholders())(\"mat-date-range-input-required\", ctx.required);\n      }\n    },\n    inputs: {\n      rangePicker: \"rangePicker\",\n      required: \"required\",\n      dateFilter: \"dateFilter\",\n      min: \"min\",\n      max: \"max\",\n      disabled: \"disabled\",\n      separator: \"separator\",\n      comparisonStart: \"comparisonStart\",\n      comparisonEnd: \"comparisonEnd\"\n    },\n    exportAs: [\"matDateRangeInput\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MatFormFieldControl,\n      useExisting: MatDateRangeInput\n    }, {\n      provide: MAT_DATE_RANGE_INPUT_PARENT,\n      useExisting: MatDateRangeInput\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c10,\n    decls: 9,\n    vars: 4,\n    consts: [[\"cdkMonitorSubtreeFocus\", \"\", 1, \"mat-date-range-input-container\", 3, \"cdkFocusChange\"], [1, \"mat-date-range-input-start-wrapper\"], [\"aria-hidden\", \"true\", 1, \"mat-date-range-input-mirror\"], [1, \"mat-date-range-input-separator\"], [1, \"mat-date-range-input-end-wrapper\"]],\n    template: function MatDateRangeInput_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c9);\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"cdkFocusChange\", function MatDateRangeInput_Template_div_cdkFocusChange_0_listener($event) {\n          return ctx.focused = $event !== null;\n        });\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementStart(3, \"span\", 2);\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"span\", 3);\n        i0.ɵɵtext(6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"div\", 4);\n        i0.ɵɵprojection(8, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵtextInterpolate(ctx._getInputMirrorValue());\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"mat-date-range-input-separator-hidden\", ctx._shouldHideSeparator());\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.separator);\n      }\n    },\n    directives: [i10.CdkMonitorFocus],\n    styles: [\".mat-date-range-input{display:block;width:100%}.mat-date-range-input-container{display:flex;align-items:center}.mat-date-range-input-separator{transition:opacity .4s .1333333333333s cubic-bezier(.25,.8,.25,1);margin:0 4px}.mat-date-range-input-separator-hidden{-webkit-user-select:none;user-select:none;opacity:0;transition:none}.mat-date-range-input-inner{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;vertical-align:bottom;text-align:inherit;-webkit-appearance:none;width:100%}.mat-date-range-input-inner::-ms-clear,.mat-date-range-input-inner::-ms-reveal{display:none}.mat-date-range-input-inner:-moz-ui-invalid{box-shadow:none}.mat-date-range-input-inner::placeholder{transition:color .4s .1333333333333s cubic-bezier(.25,.8,.25,1)}.mat-form-field-hide-placeholder .mat-date-range-input-inner::placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::placeholder{-webkit-user-select:none;user-select:none;color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-date-range-input-inner::-moz-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::-moz-placeholder{-webkit-user-select:none;user-select:none;color:transparent!important;-webkit-text-fill-color:transparent;-moz-transition:none;transition:none}.mat-form-field-hide-placeholder .mat-date-range-input-inner::-webkit-input-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::-webkit-input-placeholder{-webkit-user-select:none;user-select:none;color:transparent!important;-webkit-text-fill-color:transparent;-webkit-transition:none;transition:none}.mat-form-field-hide-placeholder .mat-date-range-input-inner:-ms-input-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner:-ms-input-placeholder{-webkit-user-select:none;user-select:none;color:transparent!important;-webkit-text-fill-color:transparent;-ms-transition:none;transition:none}.mat-date-range-input-mirror{-webkit-user-select:none;user-select:none;visibility:hidden;white-space:nowrap;display:inline-block;min-width:2px}.mat-date-range-input-start-wrapper{position:relative;overflow:hidden;max-width:calc(50% - 4px)}.mat-date-range-input-start-wrapper .mat-date-range-input-inner{position:absolute;top:0;left:0}.mat-date-range-input-end-wrapper{flex-grow:1;max-width:calc(50% - 4px)}.mat-form-field-type-mat-date-range-input .mat-form-field-infix{width:200px}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDateRangeInput;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(mmalerba): We use a component instead of a directive here so the user can use implicit\n// template reference variables (e.g. #d vs #d=\"matDateRangePicker\"). We can change this to a\n// directive if angular adds support for `exportAs: '$implicit'` on directives.\n\n/** Component responsible for managing the date range picker popup/dialog. */\n\n\nlet MatDateRangePicker = /*#__PURE__*/(() => {\n  class MatDateRangePicker extends MatDatepickerBase {\n    _forwardContentValues(instance) {\n      super._forwardContentValues(instance);\n\n      const input = this.datepickerInput;\n\n      if (input) {\n        instance.comparisonStart = input.comparisonStart;\n        instance.comparisonEnd = input.comparisonEnd;\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDateRangePicker.ɵfac = /* @__PURE__ */function () {\n    let ɵMatDateRangePicker_BaseFactory;\n    return function MatDateRangePicker_Factory(t) {\n      return (ɵMatDateRangePicker_BaseFactory || (ɵMatDateRangePicker_BaseFactory = i0.ɵɵgetInheritedFactory(MatDateRangePicker)))(t || MatDateRangePicker);\n    };\n  }();\n  /** @nocollapse */\n\n\n  MatDateRangePicker.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatDateRangePicker,\n    selectors: [[\"mat-date-range-picker\"]],\n    exportAs: [\"matDateRangePicker\"],\n    features: [i0.ɵɵProvidersFeature([MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER, MAT_CALENDAR_RANGE_STRATEGY_PROVIDER, {\n      provide: MatDatepickerBase,\n      useExisting: MatDateRangePicker\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function MatDateRangePicker_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDateRangePicker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Button that will close the datepicker and assign the current selection to the data model. */\n\n\nlet MatDatepickerApply = /*#__PURE__*/(() => {\n  class MatDatepickerApply {\n    constructor(_datepicker) {\n      this._datepicker = _datepicker;\n    }\n\n    _applySelection() {\n      this._datepicker._applyPendingSelection();\n\n      this._datepicker.close();\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerApply.ɵfac = function MatDatepickerApply_Factory(t) {\n    return new (t || MatDatepickerApply)(i0.ɵɵdirectiveInject(MatDatepickerBase));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerApply.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDatepickerApply,\n    selectors: [[\"\", \"matDatepickerApply\", \"\"], [\"\", \"matDateRangePickerApply\", \"\"]],\n    hostBindings: function MatDatepickerApply_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function MatDatepickerApply_click_HostBindingHandler() {\n          return ctx._applySelection();\n        });\n      }\n    }\n  });\n  return MatDatepickerApply;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Button that will close the datepicker and discard the current selection. */\n\n\nlet MatDatepickerCancel = /*#__PURE__*/(() => {\n  class MatDatepickerCancel {\n    constructor(_datepicker) {\n      this._datepicker = _datepicker;\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerCancel.ɵfac = function MatDatepickerCancel_Factory(t) {\n    return new (t || MatDatepickerCancel)(i0.ɵɵdirectiveInject(MatDatepickerBase));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerCancel.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatDatepickerCancel,\n    selectors: [[\"\", \"matDatepickerCancel\", \"\"], [\"\", \"matDateRangePickerCancel\", \"\"]],\n    hostBindings: function MatDatepickerCancel_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function MatDatepickerCancel_click_HostBindingHandler() {\n          return ctx._datepicker.close();\n        });\n      }\n    }\n  });\n  return MatDatepickerCancel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Container that can be used to project a row of action buttons\n * to the bottom of a datepicker or date range picker.\n */\n\n\nlet MatDatepickerActions = /*#__PURE__*/(() => {\n  class MatDatepickerActions {\n    constructor(_datepicker, _viewContainerRef) {\n      this._datepicker = _datepicker;\n      this._viewContainerRef = _viewContainerRef;\n    }\n\n    ngAfterViewInit() {\n      this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n\n      this._datepicker.registerActions(this._portal);\n    }\n\n    ngOnDestroy() {\n      var _a, _b;\n\n      this._datepicker.removeActions(this._portal); // Needs to be null checked since we initialize it in `ngAfterViewInit`.\n\n\n      if ((_a = this._portal) === null || _a === void 0 ? void 0 : _a.isAttached) {\n        (_b = this._portal) === null || _b === void 0 ? void 0 : _b.detach();\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  MatDatepickerActions.ɵfac = function MatDatepickerActions_Factory(t) {\n    return new (t || MatDatepickerActions)(i0.ɵɵdirectiveInject(MatDatepickerBase), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerActions.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatDatepickerActions,\n    selectors: [[\"mat-datepicker-actions\"], [\"mat-date-range-picker-actions\"]],\n    viewQuery: function MatDatepickerActions_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._template = _t.first);\n      }\n    },\n    ngContentSelectors: _c11,\n    decls: 1,\n    vars: 0,\n    consts: [[1, \"mat-datepicker-actions\"]],\n    template: function MatDatepickerActions_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, MatDatepickerActions_ng_template_0_Template, 2, 0, \"ng-template\");\n      }\n    },\n    styles: [\".mat-datepicker-actions{display:flex;justify-content:flex-end;align-items:center;padding:0 8px 8px}.mat-datepicker-actions .mat-button-base+.mat-button-base{margin-left:8px}[dir=rtl] .mat-datepicker-actions .mat-button-base+.mat-button-base{margin-left:0;margin-right:8px}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatepickerActions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet MatDatepickerModule = /*#__PURE__*/(() => {\n  class MatDatepickerModule {}\n\n  /** @nocollapse */\n  MatDatepickerModule.ɵfac = function MatDatepickerModule_Factory(t) {\n    return new (t || MatDatepickerModule)();\n  };\n  /** @nocollapse */\n\n\n  MatDatepickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MatDatepickerModule\n  });\n  /** @nocollapse */\n\n  MatDatepickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [MatDatepickerIntl, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER],\n    imports: [[CommonModule, MatButtonModule, MatDialogModule, OverlayModule, A11yModule, PortalModule, MatCommonModule], CdkScrollableModule]\n  });\n  return MatDatepickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CLOCK_INNER_RADIUS, CLOCK_OUTER_RADIUS, CLOCK_RADIUS, CLOCK_TICK_RADIUS, DateRange, DefaultMatCalendarRangeStrategy, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_DATEPICKER_VALIDATORS, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATE_RANGE_SELECTION_STRATEGY, MAT_RANGE_DATE_SELECTION_MODEL_FACTORY, MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER, MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY, MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER, MatCalendar, MatCalendarBody, MatCalendarCell, MatCalendarHeader, MatClockView, MatDateRangeInput, MatDateRangePicker, MatDateSelectionModel, MatDatepicker, MatDatepickerActions, MatDatepickerApply, MatDatepickerCancel, MatDatepickerContent, MatDatepickerInput, MatDatepickerInputEvent, MatDatepickerIntl, MatDatepickerModule, MatDatepickerToggle, MatDatepickerToggleIcon, MatEndDate, MatMonthView, MatMultiYearView, MatRangeDateSelectionModel, MatSingleDateSelectionModel, MatStartDate, MatYearView, matDatepickerAnimations }; //# sourceMappingURL=matheo-datepicker.js.map","map":null,"metadata":{},"sourceType":"module"}