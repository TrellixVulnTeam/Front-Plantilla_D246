{"ast":null,"code":"import * as i1 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i0 from '@angular/core';\nimport { isDevMode, Injectable, Optional, Inject, NgModule } from '@angular/core';\nimport { MAT_DATE_LOCALE, DateAdapter as DateAdapter$1, MAT_DATE_FORMATS } from '@angular/material/core';\nimport { Subject } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\n\nclass DateAdapter {\n  constructor() {\n    this._localeChanges = new Subject();\n    /** A stream that emits when the locale changes. */\n\n    this.localeChanges = this._localeChanges;\n  }\n  /**\n   * Given a potential date object, returns that same date object if it is\n   * a valid date, or `null` if it's not a valid date.\n   * @param obj The object to check.\n   * @returns A date or `null`.\n   */\n\n\n  getValidDateOrNull(obj) {\n    return this.isDateInstance(obj) && this.isValid(obj) ? obj : null;\n  }\n  /**\n   * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n   * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n   * string). The default implementation does not allow any deserialization, it simply checks that\n   * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n   * method on all of its `@Input()` properties that accept dates. It is therefore possible to\n   * support passing values from your backend directly to these properties by overriding this method\n   * to also deserialize the format used by your backend.\n   * @param value The value to be deserialized into a date object.\n   * @returns The deserialized date object, either a valid date, null if the value can be\n   *     deserialized into a null date (e.g. the empty string), or an invalid date.\n   */\n\n\n  deserialize(value) {\n    if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n      return value;\n    }\n\n    return this.invalid();\n  }\n  /**\n   * Sets the locale used for all dates.\n   * @param locale The new locale.\n   */\n\n\n  setLocale(locale) {\n    this.locale = locale;\n\n    this._localeChanges.next();\n  }\n  /**\n   * Compares two dates.\n   * @param first The first date to compare.\n   * @param second The second date to compare.\n   * @param unit Unit deep of the comparision.\n   * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n   *     a number greater than 0 if the first date is later.\n   */\n\n\n  compareDate(first, second, unit = 'minute') {\n    let d1 = this.getYear(first).toString();\n    let d2 = this.getYear(second).toString();\n\n    if (['y', 'year', 'years'].includes(unit)) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getMonth(first).toString().padStart(2, '0');\n    d2 += this.getMonth(second).toString().padStart(2, '0');\n\n    if (['M', 'month', 'months'].includes(unit)) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getDate(first).toString().padStart(2, '0');\n    d2 += this.getDate(second).toString().padStart(2, '0');\n\n    if (['d', 'day', 'days'].includes(unit)) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getHours(first).toString().padStart(2, '0');\n    d2 += this.getHours(second).toString().padStart(2, '0');\n\n    if (['h', 'hour', 'hours'].indexOf(unit) >= 0) {\n      return Number(d1) - Number(d2);\n    }\n\n    d1 += this.getMinutes(first).toString().padStart(2, '0');\n    d2 += this.getMinutes(second).toString().padStart(2, '0');\n    return Number(d1) - Number(d2);\n  }\n  /**\n   * Checks if two dates are equal.\n   * @param first The first date to check.\n   * @param second The second date to check.\n   * @returns Whether the two dates are equal.\n   *     Null dates are considered equal to other null dates.\n   */\n\n\n  sameDate(first, second, unit = 'minute') {\n    if (first && second) {\n      let firstValid = this.isValid(first);\n      let secondValid = this.isValid(second);\n\n      if (firstValid && secondValid) {\n        return !this.compareDate(first, second, unit);\n      }\n\n      return firstValid == secondValid;\n    }\n\n    return first == second;\n  }\n  /**\n   * Clamp the given date between min and max dates.\n   * @param date The date to clamp.\n   * @param min The minimum value to allow. If null or omitted no min is enforced.\n   * @param max The maximum value to allow. If null or omitted no max is enforced.\n   * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n   *     otherwise `date`.\n   */\n\n\n  clampDate(date, min, max, unit = 'minute') {\n    if (min && this.compareDate(date, min, unit) < 0) {\n      return min;\n    }\n\n    if (max && this.compareDate(date, max, unit) > 0) {\n      return max;\n    }\n\n    return date;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(mmalerba): Remove when we no longer support safari 9.\n\n/** Whether the browser supports the Intl API. */\n\n\nlet SUPPORTS_INTL_API; // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\n\ntry {\n  SUPPORTS_INTL_API = typeof Intl != 'undefined';\n} catch (_a) {\n  SUPPORTS_INTL_API = false;\n}\n/** The default month names to use if Intl API is not available. */\n\n\nconst DEFAULT_MONTH_NAMES = {\n  'long': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']\n};\n/** The default date names to use if Intl API is not available. */\n\nconst DEFAULT_DATE_NAMES = range(31, i => String(i + 1));\n/** The default hour names to use if Intl API is not available. */\n\nconst DEFAULT_HOUR_NAMES = range(24, i => i === 0 ? '00' : String(i));\n/** The default minute names to use if Intl API is not available. */\n\nconst DEFAULT_MINUTE_NAMES = range(60, String);\n/** The default day of the week names to use if Intl API is not available. */\n\nconst DEFAULT_DAY_OF_WEEK_NAMES = {\n  'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n};\n/**\n * Matches strings that have the form of a valid RFC 3339 string\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\n * because the regex will match strings an with out of bounds month, date, etc.\n */\n\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:(?:\\+|-)\\d{2}:\\d{2}))?)?$/;\n/** Creates an array and fills it with values. */\n\nfunction range(length, valueFunction) {\n  const valuesArray = Array(length);\n\n  for (let i = 0; i < length; i++) {\n    valuesArray[i] = valueFunction(i);\n  }\n\n  return valuesArray;\n}\n/** Adapts the native JS Date for use with cdk-based components that work with dates. */\n\n\nlet NativeDateAdapter = /*#__PURE__*/(() => {\n  class NativeDateAdapter extends DateAdapter {\n    constructor(matDateLocale, platform) {\n      super();\n      /**\n       * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.\n       * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off\n       * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`\n       * will produce `'8/13/1800'`.\n       *\n       * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now\n       * getting the string representation of a Date object from its utc representation. We're keeping\n       * it here for sometime, just for precaution, in case we decide to revert some of these changes\n       * though.\n       */\n\n      this.useUtcForDisplay = true;\n      super.setLocale(matDateLocale); // IE does its own time zone correction, so we disable this on IE.\n\n      this.useUtcForDisplay = !platform.TRIDENT;\n      this._clampDate = platform.TRIDENT || platform.EDGE;\n    }\n\n    getYear(date) {\n      return date.getFullYear();\n    }\n\n    getMonth(date) {\n      return date.getMonth();\n    }\n\n    getDate(date) {\n      return date.getDate();\n    }\n\n    getHours(date) {\n      return date.getHours();\n    }\n\n    setHours(date, value) {\n      const clone = this.clone(date);\n      clone.setHours(value);\n      return clone;\n    }\n\n    getMinutes(date) {\n      return date.getMinutes();\n    }\n\n    setMinutes(date, value) {\n      const clone = this.clone(date);\n      clone.setMinutes(value);\n      return clone;\n    }\n\n    getSeconds(date) {\n      return date.getSeconds();\n    }\n\n    setSeconds(date, value, ms) {\n      const clone = this.clone(date);\n      clone.setSeconds(value, ms);\n      return clone;\n    }\n\n    getMilliseconds(date) {\n      return date.getMilliseconds();\n    }\n\n    getDayOfWeek(date) {\n      return date.getDay();\n    }\n\n    getMonthNames(style) {\n      if (SUPPORTS_INTL_API) {\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          month: style,\n          timeZone: 'utc'\n        });\n        return range(12, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, i, 1))));\n      }\n\n      return DEFAULT_MONTH_NAMES[style];\n    }\n\n    getDateNames() {\n      if (SUPPORTS_INTL_API) {\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          day: 'numeric',\n          timeZone: 'utc'\n        });\n        return range(31, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n      }\n\n      return DEFAULT_DATE_NAMES;\n    }\n\n    getHourNames() {\n      return DEFAULT_HOUR_NAMES;\n    }\n\n    getMinuteNames() {\n      return DEFAULT_MINUTE_NAMES;\n    }\n\n    getDayOfWeekNames(style) {\n      if (SUPPORTS_INTL_API) {\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          weekday: style,\n          timeZone: 'utc'\n        });\n        return range(7, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n      }\n\n      return DEFAULT_DAY_OF_WEEK_NAMES[style];\n    }\n\n    getYearName(date) {\n      if (SUPPORTS_INTL_API) {\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          year: 'numeric',\n          timeZone: 'utc'\n        });\n        return this._stripDirectionalityCharacters(this._format(dtf, date));\n      }\n\n      return String(this.getYear(date));\n    }\n\n    getFirstDayOfWeek() {\n      // We can't tell using native JS Date what the first day of the week is, we default to Sunday.\n      return 0;\n    }\n\n    getNumDaysInMonth(date) {\n      return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\n    }\n\n    clone(date) {\n      return new Date(date.getTime());\n    }\n\n    createDate(year, month, date, hours = 0, minutes = 0, seconds = 0, ms = 0) {\n      if (isDevMode()) {\n        // Check for invalid month and date (except upper bound on date which we have to check after\n        // creating the Date).\n        if (month < 0 || month > 11) {\n          throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n        }\n\n        if (date < 1) {\n          throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n        }\n      }\n\n      let result = this._createDateWithOverflow(year, month, date, hours, minutes, seconds, ms); // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n\n\n      if (result.getMonth() != month && isDevMode()) {\n        throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n      }\n\n      return result;\n    }\n\n    today() {\n      return new Date();\n    }\n\n    parse(value) {\n      // We have no way using the native JS Date to set the parse format or locale, so we ignore these\n      // parameters.\n      if (typeof value == 'number') {\n        return new Date(value);\n      }\n\n      return value ? new Date(Date.parse(value)) : null;\n    }\n\n    format(date, displayFormat) {\n      if (!this.isValid(date)) {\n        throw Error('NativeDateAdapter: Cannot format invalid date.');\n      }\n\n      if (SUPPORTS_INTL_API) {\n        // On IE and Edge the i18n API will throw a hard error that can crash the entire app\n        // if we attempt to format a date whose year is less than 1 or greater than 9999.\n        if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {\n          date = this.clone(date);\n          date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));\n        }\n\n        displayFormat = Object.assign(Object.assign({}, displayFormat), {\n          timeZone: 'utc'\n        });\n        const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\n        return this._stripDirectionalityCharacters(this._format(dtf, date));\n      }\n\n      return this._stripDirectionalityCharacters(date.toDateString());\n    }\n\n    addCalendarYears(date, years) {\n      return this.addCalendarMonths(date, years * 12);\n    }\n\n    addCalendarMonths(date, months) {\n      let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date), this.getHours(date), this.getMinutes(date), this.getSeconds(date)); // It's possible to wind up in the wrong month if the original month has more days than the new\n      // month. In this case we want to go to the last day of the desired month.\n      // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n      // guarantee this.\n\n\n      if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\n        newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\n      }\n\n      return newDate;\n    }\n\n    addCalendarDays(date, days) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days, this.getHours(date), this.getMinutes(date), this.getSeconds(date));\n    }\n\n    addCalendarHours(date, hours) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date) + hours, this.getMinutes(date), this.getSeconds(date));\n    }\n\n    addCalendarMinutes(date, minutes) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date), this.getMinutes(date) + minutes, this.getSeconds(date));\n    }\n\n    addCalendarSeconds(date, seconds, ms) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date), this.getMinutes(date), this.getSeconds(date) + seconds, this.getMilliseconds(date) + ms);\n    }\n\n    toIso8601(date) {\n      return [date.getUTCFullYear(), this._2digit(date.getUTCMonth() + 1), this._2digit(date.getUTCDate())].join('-');\n    }\n    /**\n     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n     * invalid date for all other values.\n     */\n\n\n    deserialize(value) {\n      if (typeof value === 'string') {\n        if (!value) {\n          return null;\n        } // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n        // string is the right format first.\n\n\n        if (ISO_8601_REGEX.test(value)) {\n          let date = new Date(value);\n\n          if (this.isValid(date)) {\n            return date;\n          }\n        }\n      }\n\n      return super.deserialize(value);\n    }\n\n    isDateInstance(obj) {\n      return obj instanceof Date;\n    }\n\n    isValid(date) {\n      return !isNaN(date.getTime());\n    }\n\n    invalid() {\n      return new Date(NaN);\n    }\n    /** Creates a date but allows the month and date to overflow. */\n\n\n    _createDateWithOverflow(year, month, date, hours = 0, minutes = 0, seconds = 0, ms = 0) {\n      // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n      // To work around this we use `setFullYear` and `setHours` instead.\n      const d = new Date();\n      d.setFullYear(year, month, date);\n      d.setHours(hours, minutes, seconds, ms);\n      return d;\n    }\n    /**\n     * Pads a number to make it two digits.\n     * @param n The number to pad.\n     * @returns The padded number.\n     */\n\n\n    _2digit(n) {\n      return ('00' + n).slice(-2);\n    }\n    /**\n     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\n     * other browsers do not. We remove them to make output consistent and because they interfere with\n     * date parsing.\n     * @param str The string to strip direction characters from.\n     * @returns The stripped string.\n     */\n\n\n    _stripDirectionalityCharacters(str) {\n      return str.replace(/[\\u200e\\u200f]/g, '');\n    }\n    /**\n     * When converting Date object to string, javascript built-in functions may return wrong\n     * results because it applies its internal DST rules. The DST rules around the world change\n     * very frequently, and the current valid rule is not always valid in previous years though.\n     * We work around this problem building a new Date object which has its internal UTC\n     * representation with the local date and time.\n     * @param dtf Intl.DateTimeFormat object, containg the desired string format. It must have\n     *    timeZone set to 'utc' to work fine.\n     * @param date Date from which we want to get the string representation according to dtf\n     * @returns A Date object with its UTC representation based on the passed in date info\n     */\n\n\n    _format(dtf, date) {\n      // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n      // To work around this we use `setUTCFullYear` and `setUTCHours` instead.\n      const d = new Date();\n      d.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      d.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n      return dtf.format(d);\n    }\n\n  }\n\n  /** @nocollapse */\n  NativeDateAdapter.ɵfac = function NativeDateAdapter_Factory(t) {\n    return new (t || NativeDateAdapter)(i0.ɵɵinject(MAT_DATE_LOCALE, 8), i0.ɵɵinject(i1.Platform));\n  };\n  /** @nocollapse */\n\n\n  NativeDateAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NativeDateAdapter,\n    factory: NativeDateAdapter.ɵfac\n  });\n  return NativeDateAdapter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst MAT_NATIVE_DATE_FORMATS = {\n  parse: {\n    dateInput: null,\n    datetimeInput: null,\n    timeInput: null,\n    monthInput: null,\n    yearInput: null\n  },\n  display: {\n    dateInput: {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    },\n    datetimeInput: {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric'\n    },\n    timeInput: {\n      hour: 'numeric',\n      minute: 'numeric'\n    },\n    monthInput: {\n      month: 'short',\n      year: 'numeric'\n    },\n    yearInput: {\n      year: 'numeric'\n    },\n    dateA11yLabel: {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    },\n    monthLabel: {\n      month: 'short'\n    },\n    monthDayLabel: {\n      month: 'short',\n      day: 'numeric'\n    },\n    monthDayA11yLabel: {\n      month: 'long',\n      day: 'numeric'\n    },\n    monthYearLabel: {\n      year: 'numeric',\n      month: 'short'\n    },\n    monthYearA11yLabel: {\n      year: 'numeric',\n      month: 'long'\n    },\n    timeLabel: {\n      hours: 'numeric',\n      minutes: 'numeric'\n    }\n  }\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet NativeDateModule = /*#__PURE__*/(() => {\n  class NativeDateModule {}\n\n  /** @nocollapse */\n  NativeDateModule.ɵfac = function NativeDateModule_Factory(t) {\n    return new (t || NativeDateModule)();\n  };\n  /** @nocollapse */\n\n\n  NativeDateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NativeDateModule\n  });\n  /** @nocollapse */\n\n  NativeDateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: DateAdapter,\n      useClass: NativeDateAdapter\n    }, {\n      provide: DateAdapter$1,\n      useClass: NativeDateAdapter\n    }],\n    imports: [[PlatformModule]]\n  });\n  return NativeDateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MatNativeDateModule = /*#__PURE__*/(() => {\n  class MatNativeDateModule {}\n\n  /** @nocollapse */\n  MatNativeDateModule.ɵfac = function MatNativeDateModule_Factory(t) {\n    return new (t || MatNativeDateModule)();\n  };\n  /** @nocollapse */\n\n\n  MatNativeDateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MatNativeDateModule\n  });\n  /** @nocollapse */\n\n  MatNativeDateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: MAT_DATE_FORMATS,\n      useValue: MAT_NATIVE_DATE_FORMATS\n    }],\n    imports: [[NativeDateModule]]\n  });\n  return MatNativeDateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DateAdapter, MAT_NATIVE_DATE_FORMATS, MatNativeDateModule, NativeDateAdapter, NativeDateModule }; //# sourceMappingURL=matheo-datepicker-core.js.map","map":null,"metadata":{},"sourceType":"module"}